# 02.epoll实现原理，epoll使用的哪种模式， 除了epoll，了解selectpoll吗

# 02.epoll实现原理，epoll使用的哪种模式， 除了epoll，了解select/poll吗


**select和poll的缺点：**



（1）、每轮循环都要从用户空间往内核空间拷贝数据；



（2）、内核轮询，检测每个描述符有没有就绪事件，O(n);



（3）、I/O函数返回后，遍历每个描述符找到有事件就绪的描述符，O(n);



**（select、poll）和（epoll）的区别：**



（1）、select、poll每次循环都需要从用户空间向内核空间传递数据；



```plain
         epoll直接在内核空间创建事件表，每个描述符只需要传递一次；
```



（2）、select、poll在内核中以轮询的方式检测就绪事件描述符；



```plain
         epoll在每个描述符上注册回调函数，事件就绪后执行回调函数将描述符添加到就绪队列；
```



（3）、select、epoll返回后，需要遍历所有文件描述符，才能找到就绪的文件描述符；



```plain
         epoll返回后，直接得到就绪描述符不需要遍历所有描述符；
```



**epoll的两种模式：**



（1）、LT模式（电平触发）：描述符事件就绪后，如果用户没有处理完数据，epoll会一直提醒，直到处理完成；代码实现（epoll-LT.c）



（2）、ET模式（边沿触发）：高效模式。描述符事件就绪后，无论用户有没有处理完数据，epoll都只会提醒一次，所以在处理时要获取完整数据，需要循环获取所有数据；代码实现（epoll-ET.c）



```plain
//epoll-LT.c
//I/O复用：epoll() LT模式
//LT模式：描述符时间就绪后，如果用户没有处理完数据，epoll会反复提醒，直到处理完成

#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <sys/epoll.h>

#define MAXFD 10
int create_socket();
void epoll_add(int epfd,int fd)
{
    struct epoll_event ev;
    ev.events = EPOLLIN;      //LT模式
    ev.data.fd = fd;

    if( epoll_ctl(epfd,EPOLL_CTL_ADD,fd,&ev) == -1 )
    {
    perror("epoll_ctl error");
    }

}

void epoll_del(int epfd,int fd)
{
    if( epoll_ctl(epfd,EPOLL_CTL_DEL,fd,NULL) == -1 )
    {
	perror("epoll del erreo");
    }
}
int main()
{
    int sockfd = create_socket();
    assert(sockfd != -1);
    

    int epfd = epoll_create(MAXFD);
    assert(epfd != -1);
    
    epoll_add(epfd,sockfd);
     
    struct epoll_event events[MAXFD];
    while (1)
    { 
    int n = epoll_wait(epfd,events,MAXFD,5000);
    if( n == -1 )
    {
        perror("epoll error");
    }
    else if(n == 0)
    {
        printf("time out\n");
    }
    else
    {
        int i = 0;
        for(;i<n;i++)
        {
    	    if(events[i].events & EPOLLIN)
    	    {
    		if( events[i].data.fd == sockfd )
    		{
    		    struct sockaddr_in caddr;
    		    int len = sizeof(caddr);
    		    int c = accept(sockfd,(struct sockaddr*)&caddr,&len);
    		    if ( c < 0 )
    		    {
    			continue;
    		    }
    		    epoll_add(epfd,c);
    		    printf("accept = %d\n",c);
    		}
    	       else
    		{
    		    char buff[128] = {0};
    		    int num = recv(events[i].data.fd,buff,1,0);
    		    if( num <= 0)
    		    {
    			epoll_del(epfd,events[i].data.fd);
    			close(events[i].data.fd);
    			printf("one client over\n");
     
    		    }
    		    else
    		    {
    			printf("recv(%d):%s\n",events[i].data.fd,buff);
    			send(events[i].data.fd,"ok",2,0);
    		    }
    		}
    	    }
        }
    }
    }

}

int create_socket()
{
    int sockfd = socket(AF_INET,SOCK_STREAM,0);
    if(sockfd == -1)
    {
	return -1;
    }

    struct sockaddr_in saddr;
    memset(&saddr,0,sizeof(saddr));
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(6000);
    saddr.sin_addr.s_addr = inet_addr("127.0.0.1");
     
    int res = bind(sockfd,(struct sockaddr*)&saddr,sizeof(saddr));
    assert(res != -1);
    listen(sockfd,5);
    return sockfd;

}
```



```plain
//epoll-ET.c
//I/O复用：epoll()  ET模式
//ET模式必须使用非阻塞模式

#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <sys/epoll.h>
#include <fcntl.h>

#define MAXFD 10
int create_socket();
void setnonblock(int fd)
{
    int oldflg = fcntl(fd,F_GETFL);  //fcntl()可以设置非阻塞
    int newflg = oldflg | O_NONBLOCK;

    if(fcntl(fd,F_SETFL,newflg) == -1)
    {
    perror("fcntl error\n");
    }

}
void epoll_add(int epfd,int fd)
{
    struct epoll_event ev;
    ev.events = EPOLLIN | EPOLLET;    //ET模式
    ev.data.fd = fd;
    

    setnonblock(fd);
     
    if( epoll_ctl(epfd,EPOLL_CTL_ADD,fd,&ev) == -1 )
    {
    perror("epoll_ctl error");
    }

}

void epoll_del(int epfd,int fd)
{
    if( epoll_ctl(epfd,EPOLL_CTL_DEL,fd,NULL) == -1 )
    {
	perror("epoll del erreo");
    }
}
int main()
{
    int sockfd = create_socket();
    assert(sockfd != -1);
    

    int epfd = epoll_create(MAXFD);
    assert(epfd != -1);
    
    epoll_add(epfd,sockfd);
     
    struct epoll_event events[MAXFD];
    while (1)
    { 
    int n = epoll_wait(epfd,events,MAXFD,5000);
    if( n == -1 )
    {
        perror("epoll error");
    }
    else if(n == 0)
    {
        printf("time out\n");
    }
    else
    {
        int i = 0;
        for(;i<n;i++)
        {
    	    int fd = events[i].data.fd;
    	    if(events[i].events & EPOLLIN)
    	    {
    		if( fd == sockfd )
    		{
    		    struct sockaddr_in caddr;
    		    int len = sizeof(caddr);
    		    int c = accept(sockfd,(struct sockaddr*)&caddr,&len);
    		    if ( c < 0 )
    		    {
    			continue;
    		    }
    		    epoll_add(epfd,c);
    		    printf("accept = %d\n",c);
    		}
    	       else
    		{
    		    while(1)
    		    {
    			char buff[128] = {0};
    			int num = recv(fd,buff,1,0);
    			if( num == -1 )
    			{
    			    send(fd,"ok",2,0);
    			    break;
    			}
    			else if( num == 0 )
    			{
    			    epoll_del(epfd,fd);
    			    close(fd);
    			    printf("one client over\n");
    			    break;
    			}
    			else
    			{
    			    printf("buff(%d) = %s\n",fd,buff);
    			}
    		    }
    		}
    	    }
    	}
        }
    }

}

int create_socket()
{
    int sockfd = socket(AF_INET,SOCK_STREAM,0);
    if(sockfd == -1)
    {
	return -1;
    }

    struct sockaddr_in saddr;
    memset(&saddr,0,sizeof(saddr));
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(6000);
    saddr.sin_addr.s_addr = inet_addr("127.0.0.1");
     
    int res = bind(sockfd,(struct sockaddr*)&saddr,sizeof(saddr));
    assert(res != -1);
    listen(sockfd,5);
     
    return sockfd;

}
```



> 更新: 2024-04-19 15:33:46  
> 原文: <https://www.yuque.com/linuxer/gscfv1/5ccec95d75c31df0eec9f39383c5b797>