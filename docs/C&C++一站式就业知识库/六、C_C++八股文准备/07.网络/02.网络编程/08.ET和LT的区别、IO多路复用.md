# 08.ET和LT的区别、IO多路复用

# 08.ET和LT的区别、IO多路复用


LT模式和ET模式  
1、LT模式:内核如果检测就绪事件并将其通知给应用程序后,应用程序可以不立即处理该事件，因为下次调用epoll _wait时，还会将此事件通知给应用程序。  
2、ET模式:内核如果检测就绪事件并将其通知给应用程序后,应用程序必须立即处理该事件，否则下次调用epoll wait时，不会将此事件再通知给应用程序。  
3、select和poll只能工作在LT模式下，epoll支持高效的ET模式



实例说明  
1、epoll在默认情况下是LT模式，如果想要让他支持ET模式，可以在获取新连接的代码下在事件类型中加上EPOLLET。



2、LT模式下  
在每次处理客户端发过来的数据时，将每次读取数据的长度设置为5，运行结果为：



原因是：同一个事件，虽然只发了一次数据，但是这个事件将epoll_wait触发了三次。  
3、ET模式下（加上EPOLLET后）  
文件描述符是以ET模式来处理的。



4、ET模式下如何处理就绪的事件？  
因为要求应用程序必须立即处理并且处理完该事件，所以必须要用while（1）去处理。  
存在问题：  
（1）如何判断已经将本次的事件处理完成。  
解决方法：recv返回值如果是-1，并且判断全局的errno。



用返回值来判断文件读取是否完成。但是用recv处理时，如果用它来操作具体的客户端链接文件描述符，它本身是会阻塞的，如果阻塞了，是无法判断的。  
（2）为了解决recv阻塞问题，可以使得recv操作accept返回的文件描述符时以非阻塞方式处理。用fcntl()方法。



epoll的EPOLLONESHOT事件  
前言  
一个线程在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读(EPOLLIN再次被触发)，此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。但是我们期望的是一个socket连接在任一时刻都只被一个线程处理。这一点可以使用epoll的EPOLLONESHOT事件实现。



概念  
1、EPOLLONESHOT事件的文件描述符注册后，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll _ctl 函数重置该文件描述符上注册的EPOLLONESHOT事件。  
2、注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个  
socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket。  
3、尽管一个 socket在不同时间可能被不同的线程处理，但同一时刻肯定只有一个线程在为它服务。这就保证了连接的完整性，从而避免了很多可能的竞态条件。



> 更新: 2024-04-19 15:33:54  
> 原文: <https://www.yuque.com/linuxer/gscfv1/6589121c8a50ee71cf3e816f0a848c59>