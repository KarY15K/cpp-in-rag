# 07.epoll 底层为什么用红黑树不用hash

# 07.epoll 底层为什么用红黑树不用hash


## 一、epoll使用红黑树来管理文件描述符，而不是哈希表的原因


### **1、红黑树容易缩容**


红黑树容易缩容，在处理完大规模数据后能够很好的缩容。哈希表是不容易缩容的，如果某个时刻，有大量的网络请求通过哈希来记录，触发哈希表扩容，之后这个哈希表很难缩容回去，这也是为什么一些go程序oom的问题，都是go map太大了无法gc。



### **2、红黑树处理大规模数据效率高**


红黑树是一种自平衡二叉查找树，它的查询、插入和删除操作的平均复杂度都是O(log n)。而哈希表的查询、插入和删除操作的平均复杂度是O(1)，在处理一些小规模的数据时，哈希表可能表现得更出色，但在处理大规模的数据时，红黑树更加高效稳定。



### **3、红黑树能同时支持文件描述符和事件的管理**


在epoll中，红黑树能够同时支持文件描述符和事件的管理，可以快速地定位某个事件对应的文件描述符。而哈希表只能支持根据文件描述符快速查找对应的事件，而对于事件对应的文件描述符则无法快速定位，因此不符合epoll的需求。



## 二、红黑树简介


红黑树是一种**特定类型的二叉树**，它是在计算机科学中用来组织数据比如数字的块的一种结构。红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。由于每一棵红黑树都是一颗二叉排序树，因此，在对红黑树进行查找时，可以采用运用于普通二叉排序树上的查找算法，在查找过程中不需要颜色信息。



红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:



1. 结点是红色或黑色。
2. 根结点是黑色。
3. 所有叶子都是黑色。（叶子是NIL结点）
4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）
5. 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。



这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。是性质4导致路径上不能有两个连续的红色结点确保了这个结果。最短的可能路径都是黑色结点，最长的可能路径有交替的红色和黑色结点。因为根据性质5所有最长的路径都有相同数目的黑色结点，这就表明了没有路径能多于任何其他路径的两倍长。因为红黑树是一种特化的二叉查找树，所以红黑树上的只读操作与普通二叉查找树相同。



在红黑树上只读操作不需要对用于二叉查找树的操作做出修改，因为它也是二叉查找树。但是，在插入和删除之后，红黑属性可能变得违规。恢复红黑属性需要少量（O(log n)）的颜色变更（这在实践中是非常快速的）并且不超过三次树旋转（对于插入是两次）。这允许插入和删除保持为 O(log n)次，但是它导致了非常复杂的操作。



## 三、哈希表简介


散列表（Hash table，也叫哈希表），**是根据关键码值（Key value）而直接进行访问的数据结构**。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。



给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希（Hash）表，函数f(key)为哈希（Hash）函数。若关键字为**k**，则其值存放在**f(k)**的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系**f**为散列函数，按这个思想建立的表为散列表。对不同的关键字可能得到同一散列地址，即**k1≠k2**，而**f(k1)==f(k2)**，这种现象称为**冲突**（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数**f(k)**和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。



若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。



常用方法：



1. **直接寻址法**：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key)中已经有值了，就往下一个找，直到H(key)中没有值了，就放进去。
2. **数字分析法**：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
3. **平方取中法**：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。
4. **折叠法**：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。
5. **随机数法**：选择一随机函数，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。
6. **除留余数法**：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p，p≤m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。



> 更新: 2024-04-19 15:33:53  
> 原文: <https://www.yuque.com/linuxer/gscfv1/c1c9ed8afbf72b6aee542f44c8dc3e7d>