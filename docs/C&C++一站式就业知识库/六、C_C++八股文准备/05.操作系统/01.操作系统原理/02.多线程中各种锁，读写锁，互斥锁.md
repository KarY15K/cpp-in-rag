# 02.多线程中各种锁，读写锁，互斥锁

# 02.多线程中各种锁，读写锁，互斥锁


在操作系统中，常见的锁类型包括：互斥锁（Mutex Lock）、读写锁（Read-Write Lock）、自旋锁（Spin Lock）、条件变量（Condition Variable）、信号量（Semaphore）递归锁（Recursive Lock）、屏障（Barrier）等。



## 1.互斥锁（Mutex Lock）


互斥锁（Mutex Lock）是一种常见的线程同步机制，用于保护共享资源在多线程环境下的互斥访问。它提供了两个基本操作：加锁（Lock）和解锁（Unlock）。



互斥锁的原理和实现方式可以有多种，常见的实现包括使用原子操作、互斥变量、硬件指令等。下面是一个常见的互斥锁实现原理的简要分析：



1.  原子操作实现：原子操作是一种不可中断的操作，能够保证在多线程环境下的原子性。互斥锁的实现中，常用的原子操作是比较并交换（Compare and Swap，CAS）操作。具体实现中，互斥锁内部维护一个标志位，用于表示锁的状态。加锁操作通过原子的CAS操作将标志位从未锁定状态修改为锁定状态，如果修改成功则表示获取锁成功，否则需要重试。解锁操作将标志位恢复为未锁定状态。 
2.  互斥变量实现：互斥变量是一种特殊的变量，它具有原子性操作和线程同步的特性。互斥锁的实现中，互斥变量被用作一个标志位，用于表示锁的状态。加锁操作通过原子的测试和设置操作来获取互斥变量的值，如果互斥变量的值为未锁定状态，则将其设置为锁定状态，表示获取锁成功。解锁操作将互斥变量的值恢复为未锁定状态。 
3.  硬件指令实现：一些处理器架构提供了特定的硬件指令来支持互斥锁的实现。这些指令通常能够在单个指令级别上执行锁的加锁和解锁操作，具有较高的性能和效率。这些硬件指令可以保证锁的操作是原子的，从而实现线程的同步和互斥访问。 



无论使用哪种具体的实现方式，互斥锁的目标都是保护共享资源的访问，使得在同一时刻只有一个线程能够访问共享资源，其他线程需要等待。互斥锁的加锁操作和解锁操作通常需要保证原子性，以避免多线程环境下的竞争条件和数据不一致的问题。



总结来说，互斥锁是一种常见的线程同步机制，用于实现多线程环境下共享资源的互斥访问。它的实现原理可以包括原子操作、互斥变量、硬件指令等方式，旨在保证对共享资源的原子性操作和线程的同步访问。



## 2.读写锁（Read-Write Lock）


读写锁（Read-Write Lock）是一种多线程同步机制，用于在读操作和写操作之间提供更好的并发性。读写锁允许多个线程同时进行读操作，但在写操作时需要独占访问。它包含两种状态：读模式和写模式。



读写锁的原理和实现方式可以有多种，下面是一个常见的读写锁实现原理的简要分析：



1.  读优先的实现方式：在读写锁的实现中，维护一个计数器用于记录当前进行读操作的线程数量。当没有写操作时，读操作可以并发进行，读计数器递增。写操作需要独占访问，所以在进行写操作之前需要等待所有读操作结束，即读计数器为0。读操作和写操作之间的互斥访问可以通过互斥锁来实现。 
2.  写优先的实现方式：在读写锁的实现中，维护一个写标志位用于表示当前是否有进行写操作。当没有进行写操作时，读操作可以并发进行，读操作不会修改共享资源，所以是安全的。写操作需要独占访问，所以在进行写操作之前需要等待所有读操作结束，并设置写标志位。读操作和写操作之间的互斥访问可以通过互斥锁来实现。 



无论是哪种具体的实现方式，读写锁的目标是提高读操作的并发性，允许多个线程同时进行读操作，并保证在写操作时的独占访问。读操作之间可以并发进行，但读操作和写操作之间需要互斥访问，以保证数据的一致性。



读写锁的选择和使用取决于具体的应用场景。如果读操作频繁且并发性要求较高，可以选择读优先的实现方式；如果写操作较为频繁且需要保证写操作的原子性和独占访问，可以选择写优先的实现方式。



总结来说，读写锁是一种多线程同步机制，用于在读操作和写操作之间提供更好的并发性。它的实现原理可以包括读优先和写优先两种方式，旨在实现读操作的并发访问和写操作的独占访问。



## 3.自旋锁（Spin Lock）


自旋锁（Spin Lock）是一种多线程同步机制，用于保护临界区代码，以防止多个线程同时访问共享资源。与互斥锁不同，自旋锁不会使线程进入阻塞状态，而是在获取锁时不断循环检查锁是否可用，直到获取到锁为止。



以下是自旋锁的详细原理分析：



1.  初始化：自旋锁的初始状态为未锁定状态，可以理解为锁处于可用状态。 
2.  获取锁：当一个线程想要进入临界区代码时，它会尝试获取自旋锁。如果锁处于未锁定状态，线程可以立即获取锁，进入临界区执行操作。如果锁处于锁定状态，线程会进入自旋等待状态。 
3.  自旋等待：当一个线程发现自旋锁已经被其他线程锁定时，它会进入自旋等待状态。在自旋等待期间，线程会不断循环检查锁的状态是否变为可用。这里的循环是一个忙等待的过程，线程会一直占用CPU资源进行检查，直到锁被释放。 
4.  释放锁：当线程完成了临界区的操作，它会释放自旋锁，将锁的状态设置为未锁定状态，以允许其他线程获取锁。 



自旋锁的优点是避免了线程的上下文切换和进程阻塞，适用于临界区的代码执行时间短、线程竞争不激烈的情况下。然而，自旋锁也存在一些缺点，例如在自旋等待期间，线程会占用CPU资源，导致其他线程无法执行，可能会造成资源浪费。因此，自旋锁适用于多核CPU上的多线程并发操作，其中线程等待锁的时间较短。



在实际应用中，自旋锁的实现可以依赖于底层硬件提供的原子操作指令，或者通过软件的方式实现。具体的实现方式可以根据操作系统和编程语言的不同而有所差异。



## 4.条件变量（Condition Variable）


条件变量（Condition Variable）是一种多线程同步机制，用于在多个线程之间进行通信和协调。它允许一个或多个线程等待某个条件满足后才继续执行，从而避免了线程的忙等待。



以下是条件变量的详细原理分析：



1.  创建条件变量：在使用条件变量之前，需要先创建一个条件变量对象。条件变量通常与互斥锁配合使用，因此在创建条件变量之前，还需要创建一个互斥锁。 
2.  等待条件：当一个线程发现某个条件不满足时，它可以调用条件变量的等待函数来等待条件满足。等待函数会使线程进入阻塞状态，并释放之前持有的互斥锁，允许其他线程进入临界区。 
3.  条件满足时的唤醒：当某个线程改变了共享数据，使得某个条件满足时，它可以调用条件变量的唤醒函数来唤醒等待该条件的线程。被唤醒的线程会重新竞争互斥锁，获取锁后继续执行。 
4.  再次检查条件：被唤醒的线程在获取互斥锁后，会再次检查条件是否满足。如果条件仍然不满足，线程可能会继续等待或执行其他操作。 



条件变量的原理是基于等待队列的机制。当一个线程调用等待函数时，它会将自己加入到条件变量的等待队列中，并释放互斥锁。当条件满足时，唤醒函数会从等待队列中选择一个或多个线程，并通知它们重新竞争互斥锁。



需要注意的是，条件变量的使用必须与互斥锁配合使用，以确保线程在等待条件和修改共享数据时的线程安全性。互斥锁用于保护共享数据的访问，条件变量用于等待和唤醒线程。



在实际应用中，条件变量的实现通常是由操作系统提供的，底层会使用原子操作或其他同步机制来实现等待和唤醒的过程。编程语言和操作系统的不同可能会导致条件变量的具体实现方式有所差异。



## 5.信号量（Semaphore）


信号量（Semaphore）是一种多线程同步机制，用于控制对共享资源的访问。它通过一个计数器和一组等待队列来实现对资源的控制。



以下是信号量的详细原理分析：



1.  创建信号量：在使用信号量之前，需要先创建一个信号量对象，并初始化计数器的初始值。计数器表示可用资源的数量。 
2.  获取资源：当一个线程需要访问共享资源时，它会尝试获取信号量。如果信号量的计数器大于0，表示有可用资源，线程可以继续执行；如果计数器等于0，表示没有可用资源，线程需要进入等待状态。 
3.  释放资源：当一个线程使用完共享资源后，需要释放信号量，以便其他线程可以获取资源。释放操作会将计数器加1，并可能唤醒等待队列中的某个线程。 
4.  等待和唤醒：等待操作会将线程加入到信号量的等待队列中，并将线程置于阻塞状态。当信号量的计数器发生变化（释放资源或其他线程释放信号量）时，等待队列中的线程可能会被唤醒，重新竞争信号量。 



信号量的原理是基于计数器和等待队列的机制。计数器用于记录可用资源的数量，等待队列用于保存等待访问资源的线程。获取信号量时，如果计数器大于0，则线程可以继续执行；否则，线程需要进入等待状态。释放信号量时，计数器会增加，并且可能唤醒等待队列中的某个线程。



需要注意的是，信号量并不限定只能有一个线程访问资源，可以通过适当设置计数器的初始值来控制并发访问的数量。



在实际应用中，信号量的实现通常由操作系统提供，底层可能会使用原子操作、互斥锁或其他同步机制来实现对计数器和等待队列的操作。编程语言和操作系统的不同可能会导致信号量的具体实现方式有所差异。



## 6.递归锁（Recursive Lock）


也称为可重入锁，是一种特殊类型的互斥锁。与普通的互斥锁不同，递归锁允许同一个线程多次获取该锁而不会造成死锁。  
递归锁（Recursive Lock）是一种同步机制，允许同一个线程多次获取同一个锁而不会产生死锁。它允许线程在持有锁的情况下继续获取该锁，而不会被阻塞。



以下是递归锁的详细原理分析：



1.  锁的获取：当一个线程尝试获取递归锁时，它会先检查锁的状态。如果锁当前没有被其他线程持有，线程可以成功获取锁，并将锁的状态设置为属于该线程。如果锁已经被当前线程持有，线程也可以成功获取锁，并将锁的状态计数器加1，表示该线程多次获取锁的次数。 
2.  锁的释放：当一个线程释放递归锁时，它会先检查锁的状态。如果锁的状态计数器大于1，表示该线程还持有锁，只需要将计数器减1即可。如果锁的状态计数器等于1，表示该线程是最后一个持有锁的线程，需要将锁的状态清空，并唤醒等待队列中的某个线程。 
3.  等待和唤醒：递归锁的等待和唤醒机制与其他锁的机制类似。当一个线程尝试获取已被其他线程持有的递归锁时，它会被放入等待队列中，并进入阻塞状态。当递归锁的状态被释放时，可能会唤醒等待队列中的某个线程，使其有机会再次尝试获取锁。 



递归锁的原理是基于锁的状态和计数器的机制。锁的状态用于标识锁的持有者，计数器用于记录线程获取锁的次数。线程在获取锁时，会根据锁的状态和计数器来决定是否可以成功获取锁。在释放锁时，线程会根据计数器的值来判断是否需要真正释放锁，或者只是减少计数器的值。



递归锁的设计目的是解决同一个线程多次获取同一个锁的需求，避免死锁的发生。它允许线程在持有锁的情况下继续获取该锁，而不会被阻塞。但需要注意，递归锁的使用也需要谨慎，避免出现无限递归获取锁的情况，导致程序陷入死循环。



## 7.屏障（Barrier）


屏障（Barrier）是一种同步机制，用于确保多个线程在某个点上同步等待，并在满足条件时同时开始执行后续操作。屏障可以用于协调线程的执行顺序，确保线程在某个共同点上进行同步操作。



以下是屏障的详细原理分析：



1.  创建屏障：在程序中，可以通过特定的屏障接口或函数来创建一个屏障。屏障通常与一个计数器相关联，用于追踪到达屏障点的线程数量。 
2.  线程到达屏障点：当线程到达屏障点时，它会通过屏障接口或函数来通知屏障。屏障会将到达的线程数量加1，并检查是否已经达到了预定的数量。 
3.  等待和同步：如果到达屏障点的线程数量还没有达到预定的数量，那么线程会被阻塞，等待其他线程到达屏障点。一旦到达的线程数量达到预定的数量，屏障会触发一个信号，通知所有等待的线程可以开始执行后续操作。 
4.  后续操作：一旦屏障触发信号，所有等待的线程会同时开始执行后续操作。这些操作可以是并行执行的，因为屏障保证了所有线程在同一个点上同步等待。 



屏障的原理是基于计数器和同步机制。计数器用于追踪到达屏障点的线程数量，同步机制用于阻塞和唤醒线程，确保线程在达到预定数量时同时开始执行后续操作。



屏障的作用是在多线程环境中协调线程的执行顺序，确保线程在某个共同点上同步等待，并在满足条件时同时开始执行后续操作。它可以用于解决线程之间的同步问题，确保多个线程在某个关键点上进行同步操作，从而避免竞态条件和不确定性的结果。



> 更新: 2024-04-19 15:32:20  
> 原文: <https://www.yuque.com/linuxer/gscfv1/eee4e2ba376894364cd28d993556c3e0>