# 11.fork()读时共享写时拷贝

# 11.fork()读时共享写时拷贝


父子进程之间在刚fork后。父子相同处: 全局变量、.data、.bbs、.text、栈、堆、环境变量、用户ID、宿主目录（进程用户家目录）、进程工作目录、信号处理方式等等，即0~3G的用户空间是完全一样的。父子不同处: 1.进程ID   2.fork返回值   3.父进程ID    4.进程运行时间    5.闹钟(定时器)   6.未决信号集



似乎，子进程复制了父进程0-3G用户空间内容，以及父进程的PCB（内核模块在物理内存只有一份），但pid等不同。真的每fork一个子进程都要将父进程的0-3G地址空间完全拷贝一份，然后在映射至物理内存吗？当然不是，父子进程间遵循读时共享写时复制的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。



读时共享写时复制这一机制是由MMU来实现的。



注意：只有进程空间的各段的内容要发生变化时（子进程或父进程进行写操作时，都会引起复制），才会将父进程的内容复制一份给子进程。在fork之后两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。即父子进程在逻辑上仍然是严格相互独立的两个进程，各自维护各自的参数，只是在物理上实现了读时共享，写时复制。



父子进程一直共享：1. 文件描述符(打开文件的结构体) ，注意不是共享文件描述符本身这个整形数，而是共享同一个文件对应的FILE *结构体指针，其实一个文件打开后只能有一个FILE结构体，因此对于多有的进程都是共享这一个结构体，不仅仅只是父子进程。 2. mmap建立的映射区 (进程间通信详解)。



特别的，fork之后父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法。



> 更新: 2024-04-19 15:32:32  
> 原文: <https://www.yuque.com/linuxer/gscfv1/29ce2c694476d6ae7c1037f46d253b15>