# 32.介绍一下unique_lock和lock_guard区别？

# 32.介绍一下unique_lock和lock_guard区别？


## 1.锁


锁用来在多线程访问同一个资源时防止数据竞险，保证数据的一致性访问。多线程本来就是为了提高效率和响应速度，但锁的使用又限制了多线程的并行执行，这会降低效率，但为了保证数据正确，不得不使用锁，它们就是这样纠缠。



本文主要讨论 c++11 中的两种锁：lock_guard 和 unique_lock。这两种锁都可以对std::mutex进行封装，实现RAII的效果。绝大多数情况下这两种锁是可以互相替代的，区别是unique_lock比lock_guard能提供更多的功能特性（但需要付出性能的一些代价）



结合锁进行线程间同步的条件变量使用，请参考条件变量 condition variable 。



## 2.lock_guard


lock_guard 通常用来管理一个 std::mutex 类型的对象，通过定义一个 lock_guard 一个对象来管理 std::mutex 的上锁和解锁。在 lock_guard 初始化的时候进行上锁，然后在 lock_guard 析构的时候进行解锁。这样避免了人为的对 std::mutex 的上锁和解锁的管理。



定义如下：



```plain
template<class Mutex> class lock_guard;
```



它的特点如下：  
(1) 创建即加锁，作用域结束自动析构并解锁，无需手工解锁  
(2) 不能中途解锁，必须等作用域结束才解锁  
(3) 不能复制



> 注意：
>
>  
>
> lock_guard 并不管理 std::mutex 对象的声明周期，也就是说在使用 lock_guard 的过程中，如果 std::mutex 的对象被释放了，那么在 lock_guard 析构的时候进行解锁就会出现空指针错误。
>



示例代码如下：



```plain
#include <thread>
#include <mutex>
#include <iostream>

int g_i = 0;
std::mutex g_i_mutex;  

void safe_increment()
{
    const std::lock_guard<std::mutex> lock(g_i_mutex);
    ++g_i;

    std::cout << std::this_thread::get_id() << ": " << g_i << '\n';

}

int main()
{
    std::cout << "main: " << g_i << '\n';

    std::thread t1(safe_increment);
    std::thread t2(safe_increment);
     
    t1.join();
    t2.join();
     
    std::cout << "main: " << g_i << '\n';

}
```



输出：



```plain
main: 0
140641306900224: 1
140641298507520: 2
main: 2
```



## 3.unique_lock


unique_lock 和 lock_guard 一样，对 std::mutex 类型的互斥量的上锁和解锁进行管理，一样也不管理 std::mutex 类型的互斥量的声明周期。但是它的使用更加的灵活，支持的构造函数如下：



  
简单地讲，unique_lock 是 lock_guard 的升级加强版，它具有 lock_guard 的所有功能，同时又具有其他很多方法，使用起来更强灵活方便，能够应对更复杂的锁定需要。



特点如下：



+  创建时可以不锁定（通过指定第二个参数为 std::defer_lock），而在需要时再锁定 
+  可以随时加锁解锁 
+  作用域规则同 lock_grard，析构时自动释放锁 
+  不可复制，可移动 
+  条件变量需要该类型的锁作为参数（此时必须使用 unique_lock） 



示例代码：



```plain
#include <mutex>
#include <thread>
#include <chrono>

struct Box {
    explicit Box(int num) : num_things{num} {}

    int num_things;
    std::mutex m;

};

void transfer(Box &from, Box &to, int num)
{
    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);
    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);


    std::lock(lock1, lock2);
     
    from.num_things -= num;
    to.num_things += num; 

}

int main()
{
    Box acc1(100);
    Box acc2(50);

    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);
    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);
     
    t1.join();
    t2.join();

}
```



## 4.总结


所有 lock_guard 能够做到的事情，都可以使用 unique_lock 做到，反之则不然。



那么何时使用 lock_guard 呢？很简单，需要使用锁的时候，首先考虑使用 lock_guard。它简单、明了、易读。如果用它完全 ok，就不要考虑其他了。如果现实不允许，再使用 unique_lock 。



> 更新: 2024-04-19 15:30:34  
> 原文: <https://www.yuque.com/linuxer/gscfv1/2e67ffe368e007bfc9e494948c4d631e>