# 25.手撕：Unique_ptr，控制权转移(移动语义）手撕：类继承，堆栈上分别代码实现多态

# 25.手撕：Unique_ptr，控制权转移(移动语义）手撕：类继承，堆栈上分别代码实现多态


## 1.手撕 Unique_ptr，控制权转移（移动语义）


Unique_ptr 是 C++11 标准库中的一个智能指针类，用于管理动态分配的资源。它通过 RAII 技术实现自动释放所管理的资源，并且支持控制权转移（move semantics），可以将指针对象的所有权从一个对象转移到另一个对象。



以下是手撕 Unique_ptr 的示例代码：



```plain
template <typename T>
class Unique_ptr {
public:
    // 构造函数：初始化指针为 nullptr
    Unique_ptr() : ptr(nullptr) {}
    
    // 构造函数：接收一个原始指针作为参数
    explicit Unique_ptr(T* p) : ptr(p) {}
    
    // 移动构造函数：将右值引用转移赋值给左值引用
    Unique_ptr(Unique_ptr&& other) noexcept {
        this->ptr = other.ptr;
        other.ptr = nullptr;
    }
    
    // 析构函数：自动释放所管理的资源
    ~Unique_ptr() {
        delete ptr;
    }
    
    // 按值交换函数：使用 std::swap 实现快速交换两个对象
    void swap(Unique_ptr& other) noexcept {
        std::swap(this->ptr, other.ptr);
    }
    
    // 赋值运算符重载：支持控制权转移（move semantics）
    Unique_ptr& operator=(Unique_ptr&& other) noexcept {
        if (this != &other) {
            delete this->ptr;
            this->ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
    
    // 禁止拷贝构造函数和拷贝赋值运算符
    Unique_ptr(const Unique_ptr&) = delete;
    Unique_ptr& operator=(const Unique_ptr&) = delete;
    
    // 获取原始指针的引用
    T* get() const noexcept {
        return ptr;
    }
    
private:
    T* ptr;  // 原始指针，不可共享所有权
};
```



## 2.手撕类继承，堆栈上分别代码实现多态


类继承和多态是 C++ 面向对象编程中的重要概念。在类之间建立父子关系，可以使得子类继承父类的成员变量和成员函数，并且可以通过虚函数实现多态。



以下是手撕类继承并在堆栈上分别创建父子类对象并调用虚函数的示例代码：



```plain
#include <iostream>

class Base {
public:
    virtual void foo() {
        std::cout << "Base::foo()" << std::endl;
    }
};

class Derived : public Base {
public:
    void foo() override {
        std::cout << "Derived::foo()" << std::endl;
    }
};

int main() {
    Base b;  // 创建基类对象
    Derived d;  // 创建派生类对象
    
    b.foo();  // 调用基类虚函数
    d.foo();  // 调用派生类虚函数
    
    Base* pb = &b;  // 基类指针指向基类对象
    pb->foo();  // 调用基类虚函数
    
    pb = &d;  // 基类指针指向派生类对象
    pb->foo();  // 调用派生类虚函数
    
    return 0;
}
```



此示例中，Base 是父类，Derived 是子类，通过在 Base 中声明一个虚函数 foo()，并在 Derived 中重写该函数实现多态。在 main 函数中分别创建了一个基类对象和一个派生类对象，并调用它们的虚函数。最后将基类指针分别指向基类对象和派生类对象，并调用其虚函数验证多态效果。



> 更新: 2024-04-19 15:30:24  
> 原文: <https://www.yuque.com/linuxer/gscfv1/a295e0fe5d59d86a9dfa5d37ca5319e4>