# 30.stl容器了解吗？底层如何实现：vector数组，map红黑树，红黑树的实现

# 30.stl容器了解吗？底层如何实现：vector数组，map红黑树，红黑树的实现


## 1.vector


vector 的底层实现是一个动态数组，使用连续的内存空间存储元素。当向 vector 中添加元素时，如果当前容量不足，则会重新分配一段更大的内存空间，并将原有数据复制到新的内存空间中。



## 2.map


map 的底层实现是一棵红黑树（Red-Black Tree），它是一种自平衡二叉查找树。在红黑树上进行插入、删除和查找操作的时间复杂度均为 O(log n)。



## 3.unordered_map


unordered_map 的底层实现是一个哈希表（Hash Table）。当向 unordered_map 中添加元素时，会计算每个元素的哈希值，并将其放入对应的桶中。多个元素可能会散落在同一个桶中，因此每个桶都需要维护一个链表或者红黑树来处理冲突。



## 4.list


list 的底层实现是一个双向链表，每个节点保存前后两个指针和一个数据项。由于节点之间并不连续，所以无法通过下标随机访问元素。但由于可以在常数时间内插入或删除节点，在某些场景下比 vector 更加高效。



## 5.deque


deque（Double Ended Queue）也称作双端队列，它的底层实现是一个动态数组的序列，每个节点都是固定大小的块。deque 的特点是支持在队首和队尾进行常数时间的插入和删除操作，并且可以通过下标随机访问元素。



## 6.set


set 的底层实现也是一棵红黑树（Red-Black Tree）。由于红黑树具有自平衡性质，因此所有操作的时间复杂度均为 O(log n)。



## 7.unordered_set


unordered_set 的底层实现是一个哈希表（Hash Table），每个桶中保存了若干个元素。当添加或查找元素时，先计算元素的哈希值并确定所在的桶，然后对桶中所有元素进行线性查找或使用开放地址法解决冲突。



## 8.queue


queue 是一个先进先出（FIFO）的数据结构。其底层实现可以采用 vector 或者 deque。



## 9.priority_queue


priority_queue 是一个优先级队列，内部维护了一个堆（Heap），默认情况下使用大根堆来存储元素。其底层实现可以采用 vector 或者 deque。



> 更新: 2024-04-19 15:30:31  
> 原文: <https://www.yuque.com/linuxer/gscfv1/8c85573f137ec8fd32815532d9cdfd42>