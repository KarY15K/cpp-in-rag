# 28.函数参数可不可以传右值

# 28.函数参数可不可以传右值


当你需要在函数内copy参数 并且 要将copy的结果保存在非该函数的栈内 时。  
这两个条件必须同时都满足。



最典型的例子，就是STL的那些支持add操作的容器：因为在你给一个容器add元素时，你第一copy了外面传递进来的元素第二将这个元素存储在了容器里。



比如[vector](https://www.zhihu.com/search?q=vector&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A151976989%7D)的push_back就有两个版本：一个push_back的参数类型是const &，另一个是&&。



这么做的好处就是如果传递进来的是一个右值，那么此时在push_back里就只需要move而不需要copy。



比如，vec.push_back(MyClass());  // 此时参数为右值，调用第二个版本的push_back



========================== BONUS =========================



如果**只满足第一个条件而不满足第二个条件**，没有[右值引用](https://www.zhihu.com/search?q=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A151976989%7D)时我们是这样写的：



```cpp
void func1(const T &t)
{
    T local = t;
    // use local
}
```



上面这个函数，不论传递进来的实参是左值还是右值，结果都是调用了一次[copy构造函数](https://www.zhihu.com/search?q=copy%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A151976989%7D)



而如果我们这样写：



```cpp
void func2(T t)
{
    // use t
}
```



此时如果传递进来左值，那么依然调用了一次copy构造函数；而如果传递进来了右值，则调用的是move构造函数。



那么问题来了：**在只满足第一个条件的前提下**，我们是不是应该彻底放弃const T &而全部使用值传递呢？这个问题等效于：**是不是move一定比copy好所以能move就应该尽量move？**



答案是：NO。



现在很多“大牛”喜欢这么写：



```cpp
MyClass::Myclass(std::string str) : str_member(std::move(str)){}
```



在上面这行代码中，如果实参是左值，则调用一次copy一次move；如果实参是右值，则调用两次move。



而如果我们依然用以前的const std::string &str做参数，则不论实参是左值还是右值，均调用一次copy。



很显然，“大牛”默认了一个事实：



move的代价很低、低到多做一次move没什么关系（实参为左值时）；而copy代价非常高，高到用两次move换一次copy都是很值得（实参为右值时）。



因此，如果你的参数类型的确符合上面的事实，那么按照“大牛"的做法就是没问题的；但是并非所有的参数类型都符合上述事实。



以std::string为例：



因为当你传递std::string为参数且这个字符串的长度并不十分长时，如果用func1的方法，[编译器](https://www.zhihu.com/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A151976989%7D)是可以做一些优化工作的（SSO: small string optimization  这种优化是基于string内部的char *）；而如果你用func2，SSO就不存在了而SSO要比“把copy改成move所带来的优化”更优。（Effective Modern C++）



退一步讲，即使没有“短小的std::string”的优化问题，对于那些体量小的、不存在需要考虑[深拷贝](https://www.zhihu.com/search?q=%E6%B7%B1%E6%8B%B7%E8%B4%9D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A151976989%7D)和浅拷贝差别的、甚至只会使用trivial构造的类，我们依然可以使用func1的方式，就算你换用func2，对效率的提升是微乎其微甚至是不存在的。



而如果连第一个条件都不满足，怎么办？



很显然，答案是：以前怎样现在还怎样。



如果你并不在函数内copy参数，那么const T &显然是最好的方法。



> 更新: 2024-04-19 15:30:28  
> 原文: <https://www.yuque.com/linuxer/gscfv1/66a276d8cec22d8e06b75eaa7932cc9d>