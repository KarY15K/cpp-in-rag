# 04.面向对象的特性：多态原理

# 04.面向对象的特性：**多态**原理


## 1.原理介绍


多态可以让同名函数，因为函数指向对象的不同，而去调用该对象中该名称的函数。  
其实底层就是因为虚表的一些神奇操作。  
操作系统为构成多态的每个类增加了一个虚函数表。这个虚函数表中存放的就是virtual关键词修饰的虚函数的首地址。编译器运行的时候通过虚表中存储的函数首地址去调用对应的函数。从而达到我们多态的目的。



## 2.验证虚表的存在


打印两个一模一样的类的大小  
一个实现多态，一个没有实现。



```plain
namespace test7 {
	//求一个正常的class大小
	class Person {
	public:
		void test() {};
	private:
		int _a;
	};

	class Student {
	public:
		virtual void test() {};
	private:
		int _a;
	};
	void mytest() {
		Person s1;
		Student s2;
		std::cout << sizeof(s1) << std::endl;
		std::cout << sizeof(s2) << std::endl;
	}
	//求一个有虚表的class的大小

};
```



运行结果：  
我们发现实现多态的类比没实现的大四个字节（一个指针大小）



![watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lmd2VjYW5kZQ==,size_16,color_FFFFFF,t_70](./img/44549646__rAMSp4l-n1go5k1/1706178304698-c93244c1-c34b-44ad-9538-8e2075fc983a-145054.png)



## 3.对虚表中存储的函数地址进行打印


虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。利用这个特性我们进行类型强转，于是可以打印出这个续表中存储的各个函数指针的数值。



```plain
namespace test8 {
	//student 继承person 打印出指针 深入验证虚表存储的是什么
	class Person {
	public:
		virtual void Example1() {
			std::cout << "pex1" << std::endl;
		}
		virtual void Example2() {
			std::cout << "pex2" << std::endl;
		}
		virtual void Example3() {
			std::cout << "pex3" << std::endl;
		}
		virtual void Example4() {
			std::cout << "pex4" << std::endl;
		}
	private:
		int _a;
	};
	class Student : public Person {
	public:
		virtual void Example1() {
			std::cout << "sex1" << std::endl;
		}
		virtual void Example2() {
			std::cout << "sex2" << std::endl;
		}
		virtual void Example3() {
			std::cout << "sex3" << std::endl;
		}
		virtual void Example5() {
			std::cout << "sex5" << std::endl;
		}
	private:
		int _b;
	};

	typedef void(*VFPTR) ();
	void MyPrint(VFPTR vTable[])
	{
		// 依次取虚表中的虚函数指针打印并调用。调用就可以看出存的是哪个函数
		std::cout << " 虚表地址>" << vTable << std::endl;
	
		for (int i = 0; vTable[i] != nullptr; ++i)
		{
			printf(" 第%d个虚函数地址 :0X%x,->", i, vTable[i]);
			VFPTR f = vTable[i];
			f();
		}
		std::cout << std::endl;
	}
	int mytest() {
		Person s1;
		Student s2;
		//打印出虚函数表的数值
		VFPTR* vTableb = (VFPTR*)(*(int*)&s1);
		MyPrint(vTableb);
		VFPTR* vTabled = (VFPTR*)(*(int*)&s2);
		MyPrint(vTabled);
		return 0;
	}

};
```



运行结果：  
于是发现，父子类中都有一张虚表，用来存放虚函数的地址，子类重写了父类中的虚函数时，子类的虚表会指向新的地址，该地址是存放重写的虚函数的。（函数都在代码段）  
当没有重写时候，父子的虚表都指向同一个地址。



![watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lmd2VjYW5kZQ==,size_16,color_FFFFFF,t_70](./img/44549646__rAMSp4l-n1go5k1/1706178304772-c13cc416-2271-44a8-a8be-9ede1cb1300e-376512.png)



## 4.单继承和多继承的虚函数表


单继承的虚表如上面所示，父子类各有一张。而出现多继承的时候，子类中就会存在1张虚表包含了n个父类虚表的虚表，每张虚表都来自于不同的父类。  
**代码所示：**



```plain
using namespace std;
namespace test9 {
	class Base1 {
	public:
		virtual void func1() { cout << "Base1::func1" << endl; }
		virtual void func2() { cout << "Base1::func2" << endl; }
	private:
		int b1;
	};
	class Base2 {
	public:
		virtual void func1() { cout << "Base2::func1" << endl; }
		virtual void func2() { cout << "Base2::func2" << endl; }
	private:
		int b2;
	};
	class Derive : public Base1, public Base2 {
	public:
		virtual void func1() { cout << "Derive::func1" << endl; }
		virtual void func3() { cout << "Derive::func3" << endl; }
	private:
		int d1;
	};
	typedef void(*VFPTR) ();
	void PrintVTable(VFPTR vTable[])
	{
		cout << " 虚表地址>" << vTable << endl;
		for (int i = 0; vTable[i] != nullptr; ++i)
		{
			printf(" 第%d个虚函数地址 :0X%x,->", i, vTable[i]);
			VFPTR f = vTable[i];
			f();
		}
		cout << endl;
	}
	void mytest()
	{
		Derive d;
		VFPTR* vTableb1 = (VFPTR*)(*(int*)&d);
		PrintVTable(vTableb1);
		VFPTR* vTableb2 = (VFPTR*)(*(int*)((char*)&d + sizeof(Base1)));
		PrintVTable(vTableb2);
	}
};
```



**运行结果：**  
先继承的类虚表在前面，后继承的类的虚表在后边。  
子类中父类没有的虚函数会默认放在第一张虚表中。



![watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lmd2VjYW5kZQ==,size_16,color_FFFFFF,t_70](./img/44549646__rAMSp4l-n1go5k1/1706178304841-7bb59cbb-8f9f-4c5b-aade-6b4804157e31-068664.png)



## 5.结构总结


**对于一个普通的A类**  
内存布局为：函数存在数据段（类成员共享）成员变量存在栈（由具体情况而定）  
一般情况下，类大小计算只需要考虑成员变量



```plain
class A{
void func(){}
int a};
```



对于一个内部存在虚函数的B类



```plain
class B{
virtual void func(){}
int b};
```



内存布局为：函数存在数据段（类成员共享）成员变量存在栈（由具体情况而定），但是在类的起始位置会存在一个虚表指针（4/8字节）， 指向虚函数表所在位置。  
计算时需要额外考虑虚表指针。  
**多继承时的内存布局**  
C继承A，又继承B，在C的内存布局中，会按照先后顺序进行数据的存放， A前B后，A开始位置是A的虚表指针， B的开始位置是B的虚表指针，C中就有多个虚表。



**与虚继承对比**  
虚继承解决了多继承产生的菱形继承问题，底层实际是产生数据冗余和二义性的地方不存储对应数据，而是选择存储一个指向虚基表的指针，通过虚基表中的偏移量来找到对应的数据。  
多态实现了，一个对象指向谁调用谁。底层是在类的起始位置存储了一个虚函数表地址，当程序运行起来时，通过在虚函数表中查找对应的函数，来实现指向谁调用谁。



> 更新: 2024-04-19 15:29:56  
> 原文: <https://www.yuque.com/linuxer/gscfv1/6cfc55809bee401b24df8cf6dcaa4d65>