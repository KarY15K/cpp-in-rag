# 43.模版和泛型的区别

# 43.模版和泛型的区别


_泛型和模板都提供支持参数化类型的语言功能。但是，它们是不同的，有不同的用途。本主题提供了一个概述的许多差异。_



**泛型和C + +模板之间的主要差异：**



+ 泛型是通用的，直到它们在运行时类型取代。模板是专门在编译的时候，所以他们不仍然
+ 特别是公共语言运行库支持仿制药在MSIL。由于运行时知道仿制药，具体类型可以被取代时，泛型类型的引用程序集包含一个泛型类型。相比之下，模板，解决成普通类型在编译时产生的类型可能不会专门在其他组件中。
+ 专门在两个不同的组件与同类型参数的泛型是相同的类型。专门在两个不同的组件与同类型参数的模板被认为是由运行时是不同的类型。
+ 泛型一段可执行代码，用于所有的引用类型参数（这是不正确的值类型，它有一个独特的值类型实施每）作为一个单一的生成。 JIT编译器知道泛型和引用或值类型作为类型参数，能够对代码进行优化。模板生成单独的运行时代码为每个专业化。
+ 泛型不允许非类型的模板参数，，如模板<int I】C {}。模板允许他们。
+ 泛型不允许显式特例（即一个特定类型的模板的自定义实现）。模板做。
+ 泛型不允许部分专业化（类型参数）的一个子集的自定义实现。模板做。
+ 泛型不允许被用作类型参数的泛型类型的基类。模板做。
+ 不允许泛型类型参数的默认值。模板做。
+ 模板支持模板的模板参数（如模板<模板类X>类MyClass），但仿制药没有。



**结合模板和泛型**  
在仿制药的基本区别有用于构建应用程序相结合的模板和泛型的影响。例如，假设你有一个模板类，你想创建一个通用的包装，使该模板其他语言作为一种通用的。你不能有泛型类型参数，然后通过虽然模板，因为模板在编译的时候，需要有该类型的参数，但通用将无法解决，直到运行时的类型参数。嵌套一个通用的模板里面也不会奏效，因为有没有办法扩大模板在编译的时候可以在运行时实例任意泛型类型。



**例子：**下面的例子显示了一个简单的例子，使用模板和泛型。在这个例子中，模板类通过它的参数通过通用类型。相反的是不可能的。



    这个成语可能被用来当你想建立的现有通用的API与模板代码，是当地一个Visual C + +组装，或当你需要来添加额外的参数化层泛型类型，以利用某些功能时，模板不支持仿制药。



```cpp
// templates_and_generics.cpp



// compile with: /clr



using namespace System;



 



generic <class ItemType>



ref class MyGeneric {



   ItemType m_item;



 



public:



   MyGeneric(ItemType item) : m_item(item) {}



   void F() { 



      Console::WriteLine("F"); 



   }



};



 



template <class T>



public ref class MyRef {



MyGeneric<T>^ ig;



 



public:



   MyRef(T t) {



      ig = gcnew MyGeneric<T>(t);



      ig->F();



    }    



};



 



int main() {



   // instantiate the template



   MyRef<int>^ mref = gcnew MyRef<int>(11);



}



 



Output



 



F
```



> 更新: 2024-04-19 15:30:49  
> 原文: <https://www.yuque.com/linuxer/gscfv1/f68ed421d568b6c8dc5386cdcdda09c4>