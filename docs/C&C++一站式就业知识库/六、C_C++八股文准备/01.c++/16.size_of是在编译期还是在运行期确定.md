# 16.size_of是在编译期还是在运行期确定

# 16.size_of是在编译期还是在运行期确定


《C语言程序设计》中对sizeof的描述：C语言提供了一个编译时(compile-time) 一元运算符 sizeof，它可以用来计算任一对象的长度。 表达式sizeof 对象以及sizeof(类型名)将返回一个整型值，它等于指定对象或类型占用的存储空间字节数。  
依据上述描述，可以得出结论sizeof的值是在编译时确定的，而非运行期确定。  
如一下举例代码：



```cpp
// 需在C99标准的编译器下编译， ANSI C (即C89)下编译不通过
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[]) {int n;scanf("%d",&n);int arr[n];printf("%d\n",sizeof(n++));printf("%d\n",sizeof(arr));printf("%d",n);return 0;
}
```



上述代码开始输入3 给 n  
输出结果为: 4 12 3  
即sizeof(n++)中的++未执行，(在sizeof后使用函数，同样在求函数返回值大小时，函数也不会执行)但sizeof(arr) 一定不是在编译时确定的。 不同的输入得到动态数组大小不一。  
在c99没有出现之前，sizeof是由编译时确定的，sizeof对一个类型求出的值可以当一个常量来用。但C99中引入了动态数组（定义一个数组，其大小由运行时确定）导致sizeof作用于动态数组时的值不再是常量。



**结论**



sizeof是一种运算符不是函数，所得出的值在编译期确定，可以求出静态分配内存的数组的长度，但不能求出动态分配的内存的大小。



> 更新: 2024-04-19 15:30:12  
> 原文: <https://www.yuque.com/linuxer/gscfv1/ecb278e91358b26a38b94ef2d95b527b>