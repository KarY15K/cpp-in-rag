# 02.从url下图片10000张图片（写了想法，代码没写出来，http的api忘了），10台机器并行下载，怎么实现（主线程给子线程分配下载任务，从线程池取（给自己挖坑））。

# 02.从url下图片10000张图片（写了想法，代码没写出来，http的api忘了），10台机器并行下载，怎么实现（主线程给子线程分配下载任务，从线程池取（给自己挖坑））。


实现思路：



1. 首先需要一个存储所有图片 URL 的列表，可以存在数据库中或者文件中。
2. 创建一个线程池来管理下载任务。线程池的大小为 10，每个线程在完成下载任务后返回结果给主线程。
3. 主线程从存储图片 URL 的列表中读取 URL，并将其分配给空闲的子线程进行下载。如果当前没有空闲的子线程，则主线程等待直到有子线程可用。
4. 子线程下载完一张图片后，将其保存到本地并返回下载结果给主线程，然后继续等待下一个任务。
5. 当所有图片都被下载完成后，主线程结束程序。



代码实现：



```plain
python复制代码import threading
import requests

# 图片URL列表（假设已经从数据库或文件中读取）
image_urls = [
    "http://example.com/image1.jpg",
    "http://example.com/image2.jpg",
    "http://example.com/image3.jpg",
    ...
]

# 线程池大小
MAX_THREADS = 10

class DownloadThread(threading.Thread):
    def __init__(self, thread_id, task_queue):
        threading.Thread.__init__(self)
        self.thread_id = thread_id
        self.task_queue = task_queue
    
    def run(self):
        while True:
            # 从任务队列获取一个下载任务
            try:
                image_url = self.task_queue.get(block=False)
            except queue.Empty:
                break
            
            # 下载图片并保存到本地
            response = requests.get(image_url)
            with open(f"{self.thread_id}_{image_url.split('/')[-1]}", "wb") as f:
                f.write(response.content)
            
            # 将下载结果返回给主线程
            print(f"Thread {self.thread_id} downloaded image {image_url}")
            self.task_queue.task_done()

# 创建任务队列并填充任务
task_queue = queue.Queue()
for url in image_urls:
    task_queue.put(url)

# 创建线程池并启动子线程
threads = []
for i in range(MAX_THREADS):
    thread = DownloadThread(i, task_queue)
    thread.start()
    threads.append(thread)

# 等待所有任务完成
task_queue.join()

# 所有图片下载完成，结束程序
print("All images downloaded successfully.")
```



以上是一个简单的多线程下载图片的实现示例，代码中使用了 Python 的 threading 和 queue 模块来实现线程和任务队列的管理。需要注意的是，在实际应用中还需要考虑网络连接超时、异常处理等问题。



> 更新: 2024-04-19 15:34:56  
> 原文: <https://www.yuque.com/linuxer/gscfv1/1797f8af21b759303302d6e2de8d2fcf>