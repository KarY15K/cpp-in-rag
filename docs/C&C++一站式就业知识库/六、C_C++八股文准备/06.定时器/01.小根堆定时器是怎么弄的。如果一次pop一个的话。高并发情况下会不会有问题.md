# 01.小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题

# 01.小根堆定时器是怎么弄的。如果一次pop一个的话。高并发情况下会不会有问题


小根堆定时器是一种常见的定时器实现方式，其核心思想是通过一个小根堆来管理所有的定时器事件，并保证最先触发的事件始终在堆顶。



具体来说，每个定时器都被封装成一个结构体，包括到期时间、回调函数等信息。所有的定时器按照到期时间从小到大排列在小根堆中。当程序需要休眠等待下一个最近的事件发生时，只需要取出堆顶元素（即最先到期的事件）并休眠至该事件到期即可。



对于高并发情况下的问题，如果只有单线程处理定时器事件，则不会存在竞争问题。但如果有多个线程同时操作小根堆，则可能会存在竞争条件导致数据错误或性能下降。



为了避免这种情况，可以采用以下几种方案：



1. 使用线程安全的容器：例如std::priority_queue<std::shared_ptr, std::vector<std::shared_ptr>, TimerCmp>可以使用std::mutex进行线程安全保护；
2. 单线程轮询：将定时器放入队列中，在单独的线程中循环判断是否有任务过期；
3. 分段锁：将整个定时器集合分成多个部分，每个部分加锁后并发执行。



总之，小根堆定时器是一种常见且高效的定时器实现方式。在高并发情况下，需要采用适当的线程安全措施来避免竞争条件导致的问题。



> 更新: 2024-04-19 15:33:08  
> 原文: <https://www.yuque.com/linuxer/gscfv1/1bbfbbfbc813d8a27ff44915eedf98f4>