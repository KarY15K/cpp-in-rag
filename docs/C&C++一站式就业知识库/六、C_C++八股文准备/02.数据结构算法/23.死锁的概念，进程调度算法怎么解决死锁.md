# 23.死锁的概念，进程调度算法怎么解决死锁

# 23.死锁的概念，进程调度算法怎么解决死锁


0、死锁的概念和产生原因  
概念：1、多个并发进程因争夺系统资源而产生相互等待的现象。



```plain
       2、是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法                  再向前推进
```



原理：当一组进程中的每个进程都在等待某个事件发生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。



产生原因：



a、竞争资源



产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞



产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁



b. 进程间推进顺序非法



若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁



例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁



本质原因：



```plain
    1）、系统资源有限。

    2）、进程推进顺序不合理
```



1、产生的必要条件  
互斥：每个资源要么已经分配给一个进程，要么就是可用的，P1进程占用资源时，别的进程无法使用



占有和等待：已经占有资源的额进程可以再请求新的资源



不可抢占：已经分配给进程的资源不能被强制性抢占，它只能被占有它的进程显式地释放，资源只能由资源占有者主动释放



环路等待：有两个或两个以上的进程组成环路，该环路中每个进程都在等待下一个进程所占有的资源



```plain
              P1 占用了P2的资源，P2占用了P3的资源，P3占用了P1的资源，形成等待环路
```



2、处理方法：  
鸵鸟策略  
死锁检测和死锁恢复（不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。）  
死锁预防（在程序运行之前预防）  
死锁避免（在程序运行时避免发生死锁）  
A、鸵鸟策略：  
解决死锁问题代价很高，当死锁对用户不会有多大危害时，或者发生的概率很低时，直接不用处理



Linux、Windows、Unix处理死锁的问题 大部分时间都是忽略它



B、死锁检测和死锁恢复（解除）：  
1、先检测：



此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源。检测方法包括定时检测、效率低时检测、进程等待时检测等。  
2、解除死锁：



采取适当措施，从系统中将已发生的死锁清除掉。  
这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。



常用的实施方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。



如果我们在死锁检查时发现了死锁情况，那么就要努力消除死锁，使系统从死锁状态中恢复过来。



消除死锁的几种方式：



最简单、最常用的方法就是进行系统的重新启动，缺点：代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程；



撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；



进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。



死锁的解除补充：



如果利用死锁检测算法检测出系统已经出现了死锁 ，那么，常用的解除死锁的方法：



1、抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程，以解除死锁状态。



2、终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态。



```plain
a、终止所有的死锁进程。这种方式简单粗暴，但是代价很大，很有可能会导致一些已经运行了很久的进程前功尽弃。

b、逐个终止进程，直至死锁状态解除。该方法的代价也很大，因为每终止一个进程就需要使用死锁检测来检测系统当前是否处于死锁状态。另外，每次终止进程的时候终止那个进程呢？每次都应该采用最优策略来选择一个“代价最小”的进程来解除死锁状态。
```



一般根据如下几个方面来决定终止哪个进程：



```plain
进程的优先级

进程已运行时间以及运行完成还需要的时间

进程已占用系统资源

进程运行完成还需要的资源

终止进程数目

进程是交互还是批处理
```



C、死锁避免：  
两种避免办法：



```plain
1、如果一个进程的请求会导致死锁，则不启动该进程

2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请
```



D、死锁预防：（确保程序永远不会进入死锁状态）：  
打破四个必要条件之一就能有效预防死锁的发生；由于互斥条件是非共享资源所必须的，不仅不能改变，还应加以保证，所以，主要是破坏产生死锁的其他三个条件。



a、破坏“占有且等待”条件



```plain
 方法1：所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。

 方法2：该方法是对第一种方法的改进，允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。这样的话，资源的利用率会得到提高，也会减少进程的饥饿问题。
```



b、破坏“不可抢占”条件



```plain
  当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。这就意味着进程已占有的资源会被短暂地释放或者说是被抢占了。

  该种方法实现起来比较复杂，且代价也比较大。释放已经保持的资源很有可能会导致进程之前的工作实效等，反复的申请和释放资源会导致进程的执行被无限的推迟，这不仅会延长进程的周转周期，还会影响系统的吞吐量。
```



c、破坏“循环等待”条件



```plain
 可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。
```



补充：



打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。



打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。



打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行不然就等待，这样就不会占有且申请。



打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源



> 更新: 2024-04-19 15:31:36  
> 原文: <https://www.yuque.com/linuxer/gscfv1/0b670c661ba10ef9f1b5e963d938ebb9>