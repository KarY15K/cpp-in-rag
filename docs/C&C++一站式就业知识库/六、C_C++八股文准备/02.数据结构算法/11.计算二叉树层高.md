# 11.计算二叉树层高

# 11.计算二叉树层高


计算二叉树的层高可以使用递归或迭代两种方法。



1. 递归



计算二叉树的层高，可以通过递归遍历二叉树的每一层，并将每个节点的左右子节点分别作为一个新的子树进行递归。最终得到的结果是整个树中左右子树层数的较大值加上1，即为该二叉树的层高。



代码如下：



```plain
java复制代码public static int getDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = getDepth(root.left);   // 左子树深度
    int rightDepth = getDepth(root.right); // 右子树深度
    return Math.max(leftDepth, rightDepth) + 1;  // 返回左右子树深度较大值加上1
}
```



时间复杂度：O(n)，其中n为二叉树中节点数。



空间复杂度：O(h)，其中h为二叉树的高度，递归时系统调用堆栈所需空间。



1. 迭代



使用迭代方式计算二叉树的层高，则需要借助队列数据结构来保存每一层中所有节点信息。首先将整棵二叉树的跟节点入队，然后在循环体中依次取出队列头部元素，并将其左右子节点入队，同时记录下每一层节点的个数。当队列为空时，所记录的层数即为二叉树的层高。



代码如下：



```plain
java复制代码public static int getDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    int depth = 0;
    while (!queue.isEmpty()) {
        depth++;   // 记录当前层数
        int levelSize = queue.size();   // 记录当前层中节点数
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll();
            if (node.left != null) {
                queue.offer(node.left);   // 将左子节点入队
            }
            if (node.right != null) {
                queue.offer(node.right);  // 将右子节点入队
            }
        }
    }
    return depth;
}
```



时间复杂度：O(n)，其中n为二叉树中节点数。



空间复杂度：O(w)，其中w为二叉树最大宽度（即所有层中节点个数的最大值），需要使用队列来保存每一层中的所有节点信息。



> 更新: 2024-04-19 15:31:20  
> 原文: <https://www.yuque.com/linuxer/gscfv1/a74ffeefea8faff4646ae9d53a08399f>