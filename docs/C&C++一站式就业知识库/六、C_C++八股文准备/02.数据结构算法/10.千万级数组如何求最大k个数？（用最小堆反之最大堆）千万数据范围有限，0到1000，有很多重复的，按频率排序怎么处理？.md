# 10.千万级数组如何求最大k个数？（用最小堆反之最大堆）千万数据范围有限，0到1000，有很多重复的，按频率排序怎么处理？

# 10.千万级数组如何求最大k个数？（用最小堆反之最大堆）千万数据范围有限，0到1000，有很多重复的，按频率排序怎么处理？


针对千万级数组求最大k个数，可以使用最小堆实现。



具体步骤如下：



1. 创建一个大小为k的最小堆（Java中可以使用PriorityQueue来实现）；
2. 遍历整个数组，将每个元素加入到堆中；
3. 如果堆的大小超过了k，则弹出堆顶元素（即当前最小值）；
4. 遍历完整个数组后，堆中剩余的k个元素就是原始数组中的最大k个数。



代码实现如下：



```plain
java复制代码public static List<Integer> getTopK(int[] nums, int k) {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);  // 创建大小为k的最小堆
    for (int num : nums) {
        minHeap.offer(num);  // 将num加入到堆中
        if (minHeap.size() > k) {
            minHeap.poll();  // 如果堆的大小超过了k，则弹出堆顶元素
        }
    }
    
    List<Integer> res = new ArrayList<>(minHeap);
    Collections.sort(res, Collections.reverseOrder());  // 最后将结果从大到小排序
    return res;
}
```



时间复杂度：O(nlogk)，其中n为数组长度。因为每次插入和删除操作都要花费log(k)的时间，而一共进行n次操作。



空间复杂度：O(k)，因为需要维护一个大小为k的最小堆。



对于有重复元素且按频率排序的问题，可以使用HashMap来统计每个元素出现的频率，并将元素和其对应的频率存储在一个自定义类中。然后再以此类作为元素插入到最小堆中。



具体步骤如下：



1. 创建一个HashMap，遍历整个数组，在HashMap中统计每个元素出现的频率；
2. 创建一个大小为k的最小堆（Java中可以使用PriorityQueue来实现）；
3. 遍历HashMap，将其中所有元素按照出现频率加入到堆中；
4. 如果堆的大小超过了k，则弹出堆顶元素（即当前最小值）；
5. 遍历完整个HashMap后，堆中剩余的k个元素就是原始数组中出现频率最高的k个数。



代码实现如下：



```plain
java复制代码public static List<Integer> getTopKFrequent(int[] nums, int k) {
    Map<Integer, Integer> frequency = new HashMap<>();
    for (int num : nums) {
        frequency.put(num, frequency.getOrDefault(num, 0) + 1);  // 统计每个数字出现的次数
    }

    PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(new Comparator<Map.Entry<Integer, Integer>>() {
        @Override
        public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
            return o1.getValue() - o2.getValue();  // 按照value从小到大排序
        }
    });

    for (Map.Entry<Integer, Integer> entry : frequency.entrySet()) {
        minHeap.offer(entry);  // 将entry加入到堆中
        if (minHeap.size() > k) {
            minHeap.poll();  // 如果堆的大小超过了k，则弹出堆顶元素
        }
    }

    List<Integer> res = new ArrayList<>();
    while (!minHeap.isEmpty()) {
        res.add(minHeap.poll().getKey());  // 将所有元素从小到大取出并加入结果集中
    }

    Collections.reverse(res);  // 最后将结果反转为从大到小排序
    return res;
}
```



时间复杂度：O(nlogk)，其中n为数组长度。因为HashMap的遍历和PriorityQueue的操作都需要花费log(k)的时间，而一共进行n次操作。



空间复杂度：O(n+k)，因为需要维护一个大小为k的最小堆和一个HashMap来存储每个元素出现的频率。



> 更新: 2024-04-19 15:31:19  
> 原文: <https://www.yuque.com/linuxer/gscfv1/a85ad0f78a83e717093ed0ece5f20b68>