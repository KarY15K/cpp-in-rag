# 03.堆排序是怎么做的

# 03.堆排序是怎么做的


堆是一种叫做**完全二叉树**[[1]](https://zhuanlan.zhihu.com/p/508713899#ref_1)的数据结构。



## 1.堆的性质


+ 大顶堆：每个节点的值都大于或者等于它的左右子节点的值: arr[i] >= arr[2i + 1] && arr[i] >= arr[2i + 2]
+ 小顶堆：每个节点的值都小于或者等于它的左右子节点的值: arr[i] <= arr[2i + 1] && arr[i] <= arr[2i + 2]



![v2-a0a4360e43447d443b4a384978bfbe66_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283503-44b19e6e-c263-44f1-bd05-5f6a13a8d631-839162.webp)



把这种逻辑结构映射到数组: [9, 5, 8, 2, 3, 4, 7, 1] 和 [1, 3, 5, 4, 2, 8, 9, 7]



## 2.堆排序


堆排序的基本思想是：



1. 将带排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；
2. 将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；
3. 重复步骤2，如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。最后，就得到一个有序的序列了。



**举例演示过程**：



假设给定的无序序列arr是：【4, 5, 8, 2, 3, 9, 7, 1】



+ **1 将无序序列构建成一个大顶堆。**



首先我们将现在的无序序列看成一个堆结构，一个没有规则的二叉树，将序列里的值按照从上往下，从左到右依次填充到二叉树中



![v2-fd0b4c35afe077067b3ccff7955b6e85_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283546-b029e77d-d430-435d-a7dc-5a01dc4a125a-162137.webp)



根据大顶堆的性质，每个节点的值都大于或者等于它的左右子节点的值。从下往上的方式不需要考虑父节点，因为当前节点调整完之后，当前节点必然比它的所有子节点都大。



> 如何知道最后一个非叶子节点的位置，也就是索引值？
>



对于一个完全二叉树，在填满的情况下（非叶子节点都有两个子节点），每一层的元素个数是上一层的二倍，根节点数量是1，所以最后一层的节点数量，一定是之前所有层节点总数+1，所以，我们能找到最后一层的第一个节点的索引，即节点总数/2（根节点索引为0），这也就是第一个叶子节点，所以第一个非叶子节点的索引就是第一个叶子结点的索引-1。那么对于填不满的二叉树呢？这个计算方式仍然适用，当我们从上往下，从左往右填充二叉树的过程中，**第一个叶子节点，一定是序列长度/2，所以第一个非叶子节点的索引就是arr.length / 2 -1**。



现在找到了最后一个非叶子节点，即元素值为2的节点，比较它的左右节点的值，是否比他大，如果大就换位置。这里因为1<2，所以，不需要任何操作，继续比较下一个，即元素值为8的节点，它的左节点值为9比它本身大，所以需要交换：



![v2-e96b3633090b54e2b0f091d2eb20477d_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283564-9d18fff1-f2de-47da-a703-e34898988f8a-882573.webp)



交换后的序列：[4 5 9 2 3 8 7 1]



因为元素8没有子节点，所以继续比较下一个非叶子节点，元素值为5的节点，它的两个子节点值都比本身小，不需要调整；然后是元素值为4的节点，也就是根节点，因为9>4，所以需要调整位置



![v2-71fbde42ec6fb0464072a5d4d69c9205_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283738-1bd5e5fe-c971-435f-b24e-dafd40dd7d04-383810.webp)



交换后的序列为：[9 5 4 2 3 8 7 1]



此时，原来元素值为9的节点值变成4了，而且它本身有两个子节点，所以，这时需要再次调整该节点



![v2-d26aedc687e5796f3a9eff1ad41bc1ca_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283743-bcf4e4fe-f792-4236-8231-ff46efb6c671-434388.webp)



交换后的序列为：[9 5 8 2 3 4 7 1]



到此，大顶堆就构建完毕了。满足大顶堆的性质。



+ **2 排序序列，将堆顶的元素值和尾部的元素交换**



![v2-60e9b36daf4cb49f1a6c4fa76979971c_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283520-e9859417-b2a0-40ae-81bf-b95d72c11807-933967.webp)



交换后的序列为：[1 5 8 2 3 4 7 9]



然后将剩余的元素重新构建大顶堆，其实就是调整根节点以及其调整后影响的子节点，因为其他节点之前已经满足大顶堆性质。



![v2-06e4bb04a1e527ccce50bf71513aa474_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283570-68e66dfc-ecff-4895-83e3-3d10df36840a-954221.webp)



交换后的序列为：[8 5 7 2 3 4 1 9]



然后，继续交换，堆顶节点元素值为8与当前尾部节点元素值为1的进行交换



![v2-7a7f84e0c11201bdd11b83777b0aa4ac_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283531-efb51369-c53b-4744-b32c-d920e67f6523-939865.webp)



交换后的序列为：[1 5 7 2 3 4 8 9]



重新构建大顶堆



![v2-0b80947b2235932ece90f6c746c2fc2a_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283560-61b92fa3-2626-4788-8a6b-83032e86167e-207272.webp)



交换后的序列为：[7 5 4 2 3 1 8 9]



重复上述过程，直至数组所有遍历一遍：



![v2-5de970b497a60e6e960f8a67ca4a996c_720w.webp](./img/44549646_YI4kqWn145orIdmX/1724989283495-75d2a86a-7e6c-4c19-a128-a54742cb0b31-532196.webp)



交换后的序列为：[1 2 3 4 5 7 8 9]



## 3.堆排序的代码实现


```latex
# 堆排序
import math
import heapq


class HeapSort(object):

    def heapSort(self, arr):
        if not arr or len(arr) == 0:
            return
        N = len(arr)
        # 构建大顶堆，这里就是把排序序列，变成一个大顶堆结构数组
        self.buildMaxHeap(arr, N)
        # 交换堆顶和当前末尾的节点，重置大顶堆
        for i in range(N - 1, -1, -1):
            self.swap(arr, 0, i)
            N -= 1
            self.buildMaxHeap(arr, N)
        return arr

    def buildMaxHeap(self, arr, N):
        # 从最后一个非叶节点开始向前遍历，调整节点性质，使之成为大顶堆
        for i in range(math.floor(N / 2) - 1, -1, -1):
            self.heapify(arr, i, N)

    def heapify(self, arr, i, N):
        # 先根据堆性质， 找出它左右节点的索引
        left = 2 * i + 1
        right = 2 * i + 2
        largestIndex = i  # 默认当前节点（父节点）是最大值
        if left < N and arr[left] > arr[largestIndex]:
            largestIndex = left
        if right < N and arr[right] > arr[largestIndex]:
            largestIndex = right

        if largestIndex != i:
            # 如果最大值不是当前非叶子节点的值，那么就把当前节点和最大值的子节点值互换
            self.swap(arr, i, largestIndex)
            # 因为互换之后，子节点的值变了，如果该子节点也有自己的子节点，仍需要再次调整。
            self.heapify(arr, largestIndex, N)

    def swap(self, arr, i, j):
        temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp

    def python_func(self, arr):
        # python 堆排序的函数库
        heap = []
        for num in arr:
            heapq.heappush(heap, num)
        heapsort = [heapq.heappop(heap) for _ in range(len(heap))]
        print(heapsort)


if __name__ == '__main__':
    so = HeapSort()
    arr = [4, 5, 8, 2, 3, 9, 7, 1, 1]
    print(so.heapSort(arr))
    print(so.python_func(arr))
```



## 4. 复杂度分析


因为堆排序无关乎初始序列是否已经排序已经排序的状态，始终有两部分过程，构建初始的大顶堆的过程时间复杂度为O(n)，交换及重建大顶堆的过程中，需要交换n-1次，重建大顶堆的过程根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以它**最好和最坏的情况时间复杂度都是O(nlogn)**，空间复杂度O(1)。



> 更新: 2024-04-19 15:31:07  
> 原文: <https://www.yuque.com/linuxer/gscfv1/fcad70ac5265928089742862553db519>