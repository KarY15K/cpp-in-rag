# 第三部分：数据库设计



数据库设计是构建高效、可靠数据库系统的关键步骤。本部分将介绍数据库设计的基本原则和实践，帮助你设计出结构良好的数据库。

## 1. 表设计规范
### 1.1 命名规范
```sql
-- 表名使用小写字母，单词间用下划线分隔，使用名词复数形式
CREATE TABLE users (
    -- 字段同样使用小写字母，单词间用下划线分隔
    user_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID，自增主键',
    username VARCHAR(50) NOT NULL COMMENT '用户名，唯一标识',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'
) COMMENT '用户表';
```

**命名规范说明**：

+ 表名规范：
    - 使用小写字母和下划线（user_orders而非userOrders或UserOrders）
    - 通常使用复数形式（users而非user）
    - 表名应反映表中存储的实体类型
    - 避免使用MySQL保留字和关键字
+ 字段名规范：
    - 同样使用小写字母和下划线
    - 字段名应明确表示其内容
    - 避免过于简短的命名，如a, b, c等
    - 主键通常命名为id或[表名单数]_id

### 1.2 数据类型选择
```sql
CREATE TABLE products (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '商品ID，自增主键',
    name VARCHAR(100) NOT NULL COMMENT '商品名称，不超过100个字符',
    price DECIMAL(10,2) NOT NULL COMMENT '商品价格，最多8位整数，2位小数',
    description TEXT COMMENT '商品描述，长文本',
    is_available TINYINT(1) COMMENT '是否可用：1可用，0不可用',
    category_id SMALLINT UNSIGNED COMMENT '分类ID，范围较小',
    image_url VARCHAR(255) COMMENT '图片URL',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'
) COMMENT '商品表';
```

**数据类型选择指南**：

+ 整数类型：
    - TINYINT：很小的整数范围(-128到127)，如状态标志
    - SMALLINT：小范围整数，如分类ID
    - INT：常规整数，最常用
    - BIGINT：非常大的整数，如统计数据
    - 添加UNSIGNED可使范围从0开始，扩大正数范围
+ 小数类型：
    - DECIMAL(M,D)：精确小数，M是总位数，D是小数位数
    - FLOAT/DOUBLE：浮点数，不要用于财务数据
+ 字符串类型：
    - CHAR(N)：固定长度字符串，适合长度固定的数据
    - VARCHAR(N)：可变长度字符串，常用类型
    - TEXT：长文本，不限制长度
+ 日期时间类型：
    - DATE：只存储日期
    - TIME：只存储时间
    - DATETIME：存储日期和时间，与时区无关
    - TIMESTAMP：存储日期和时间，与时区有关

### 1.3 字段设计原则
```sql
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID，自增主键',
    order_no VARCHAR(20) NOT NULL UNIQUE COMMENT '订单编号，业务唯一标识',
    user_id INT NOT NULL COMMENT '用户ID，外键',
    payment_amount DECIMAL(10,2) NOT NULL COMMENT '支付金额',
    status TINYINT DEFAULT 1 COMMENT '订单状态：1待付款，2已付款...',
    payment_method TINYINT COMMENT '支付方式：1微信，2支付宝...',
    shipping_address VARCHAR(200) NOT NULL COMMENT '收货地址',
    contact_phone VARCHAR(20) NOT NULL COMMENT '联系电话',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_user_id (user_id) COMMENT '用户ID索引',
    INDEX idx_order_no (order_no) COMMENT '订单编号索引'
) COMMENT '订单表';
```

**字段设计原则**：

1. 每个字段存储单一数据：避免在一个字段中存储多个值
2. 适当使用默认值：为常用字段设置合理的默认值
3. 明确NOT NULL约束：非空字段应明确标注
4. 添加注释：每个字段都应有清晰的注释
5. 考虑索引：经常用于查询条件的字段应建立索引
6. 跟踪时间戳：记录创建和更新时间
7. 使用合适的键类型：业务主键与技术主键分离
8. 固定值使用枚举或小整数：如状态、类型等

## 2. 主键和外键
### 2.1 主键设计
```sql
-- 使用自增整数作为主键
CREATE TABLE customers (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '客户ID，自增主键',
    customer_no VARCHAR(20) UNIQUE COMMENT '客户编号，业务唯一标识',
    name VARCHAR(100) NOT NULL COMMENT '客户名称',
    contact_name VARCHAR(50) COMMENT '联系人姓名',
    phone VARCHAR(20) COMMENT '联系电话'
) COMMENT '客户表';

-- 使用组合主键
CREATE TABLE order_items (
    order_id INT COMMENT '订单ID',
    product_id INT COMMENT '商品ID',
    quantity INT NOT NULL COMMENT '数量',
    price DECIMAL(10,2) NOT NULL COMMENT '单价',
    PRIMARY KEY (order_id, product_id) COMMENT '组合主键：订单ID+商品ID',
    INDEX idx_product_id (product_id) COMMENT '商品ID索引'
) COMMENT '订单明细表';
```

**主键设计原则**：

1. 唯一性：主键必须唯一标识每一行
2. 不可为空：主键不允许NULL值
3. 稳定性：主键值一旦生成不宜修改
4. 简单性：主键应尽可能简单，便于索引
5. 自增主键：
    - 优点：简单高效，避免分布式ID生成问题
    - 缺点：暴露记录数量，不适合分布式系统
6. UUID主键：
    - 优点：全局唯一，适合分布式系统
    - 缺点：存储空间大，索引效率低
7. 组合主键：
    - 适用于关联表或特定业务场景
    - 可能导致索引开销增加

### 2.2 外键设计
```sql
-- 创建带外键约束的表
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID，自增主键',
    user_id INT NOT NULL COMMENT '用户ID，外键',
    total_amount DECIMAL(10,2) NOT NULL COMMENT '订单总金额',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    CONSTRAINT fk_orders_users FOREIGN KEY (user_id) REFERENCES users(id) COMMENT '外键：关联用户表'
) COMMENT '订单表';

-- 创建带外键约束和级联操作的表
CREATE TABLE order_items (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '明细ID，自增主键',
    order_id INT NOT NULL COMMENT '订单ID，外键',
    product_id INT NOT NULL COMMENT '商品ID，外键',
    quantity INT NOT NULL COMMENT '数量',
    price DECIMAL(10,2) NOT NULL COMMENT '单价',
    CONSTRAINT fk_items_orders FOREIGN KEY (order_id) 
        REFERENCES orders(id) 
        ON DELETE CASCADE 
        ON UPDATE CASCADE COMMENT '外键：关联订单表，级联删除和更新',
    CONSTRAINT fk_items_products FOREIGN KEY (product_id) 
        REFERENCES products(id) 
        ON DELETE RESTRICT
        ON UPDATE CASCADE COMMENT '外键：关联商品表，限制删除，级联更新'
) COMMENT '订单明细表';
```

**外键及级联操作说明**：

1. 外键定义：
    - FOREIGN KEY (字段名) REFERENCES 父表(字段名)
    - 外键字段与被引用字段类型必须相同
2. 级联操作：
    - ON DELETE CASCADE：删除父表记录时，自动删除子表关联记录
    - ON UPDATE CASCADE：更新父表主键时，自动更新子表外键
    - ON DELETE RESTRICT：如果子表有关联记录，禁止删除父表记录
    - ON DELETE SET NULL：删除父表记录时，子表外键设为NULL（要求外键允许NULL）
3. 外键优缺点：
    - 优点：保证数据完整性，防止孤立记录
    - 缺点：可能影响性能，增加复杂性，限制分布式扩展

### 2.3 实际应用中的考量
在实际项目中，外键使用需要权衡：

+ 小型项目：建议使用外键约束，保证数据完整性
+ 大型项目：可能在应用层实现外键逻辑，提高数据库性能
+ 分布式系统：通常避免使用外键约束

示例：不使用外键约束的替代方案

```sql
-- 不使用外键约束，但在应用层保证数据完整性
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID，自增主键',
    user_id INT NOT NULL COMMENT '用户ID，逻辑外键',
    total_amount DECIMAL(10,2) NOT NULL COMMENT '订单总金额',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX idx_user_id (user_id) COMMENT '用户ID索引'
) COMMENT '订单表';
```

## 3. 约束条件
### 3.1 常用约束类型
```sql
CREATE TABLE employees (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '员工ID，自增主键',
    employee_no VARCHAR(20) NOT NULL UNIQUE COMMENT '员工编号，唯一',
    name VARCHAR(50) NOT NULL COMMENT '姓名，非空',
    email VARCHAR(100) UNIQUE COMMENT '邮箱，唯一',
    phone VARCHAR(20) COMMENT '电话号码',
    department_id INT NOT NULL COMMENT '部门ID',
    salary DECIMAL(10,2) NOT NULL CHECK (salary > 0) COMMENT '薪资，必须大于0',
    hire_date DATE NOT NULL COMMENT '入职日期',
    birth_date DATE COMMENT '出生日期',
    gender CHAR(1) CHECK (gender IN ('M', 'F')) COMMENT '性别：M男性，F女性',
    status TINYINT DEFAULT 1 NOT NULL COMMENT '状态：1在职，0离职',
    CONSTRAINT uk_emp_email_phone UNIQUE (email, phone) COMMENT '邮箱电话组合唯一',
    INDEX idx_department (department_id) COMMENT '部门索引'
) COMMENT '员工表';
```

**约束类型说明**：

1. PRIMARY KEY：主键约束，确保唯一性和非空
2. UNIQUE：唯一约束，确保值唯一，允许NULL
3. NOT NULL：非空约束，确保必须有值
4. CHECK：检查约束，验证字段值满足特定条件
5. DEFAULT：默认值约束，未指定值时使用默认值
6. FOREIGN KEY：外键约束，确保引用完整性
7. 组合约束：多个字段组合形成的约束

### 3.2 创建和管理约束
```sql
-- 创建表时定义约束
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '商品ID',
    sku VARCHAR(50) NOT NULL COMMENT '商品编码',
    name VARCHAR(100) NOT NULL COMMENT '商品名称',
    price DECIMAL(10,2) NOT NULL COMMENT '价格',
    CONSTRAINT uk_product_sku UNIQUE (sku) COMMENT 'SKU唯一约束'
) COMMENT '商品表';

-- 添加约束
ALTER TABLE products
ADD CONSTRAINT check_price CHECK (price > 0) COMMENT '价格必须大于0';

-- 删除约束
ALTER TABLE products
DROP CONSTRAINT check_price;

-- 添加唯一约束
ALTER TABLE products
ADD CONSTRAINT uk_product_name UNIQUE (name) COMMENT '商品名称唯一';

-- 删除唯一约束
ALTER TABLE products
DROP INDEX uk_product_name;
```

**约束管理说明**：

1. 创建约束方式：
    - 在CREATE TABLE语句中直接定义
    - 使用ALTER TABLE添加现有表的约束
2. 约束命名规范：
    - 建议为约束明确命名，便于管理
    - 命名格式：约束类型缩写_表名_字段名
    - 例如：pk_表名、uk_表名_字段名、fk_表名_关联表名
3. 查看表的约束：

```sql
SHOW CREATE TABLE 表名;
```

4. 删除约束方式：
    - PRIMARY KEY：`ALTER TABLE 表名 DROP PRIMARY KEY;`
    - UNIQUE：`ALTER TABLE 表名 DROP INDEX 约束名;`
    - FOREIGN KEY：`ALTER TABLE 表名 DROP FOREIGN KEY 约束名;`
    - CHECK：`ALTER TABLE 表名 DROP CONSTRAINT 约束名;`

## 4. 规范化设计
规范化是减少数据冗余、提高数据一致性的过程。

### 4.1 第一范式（1NF）
**原则：每个字段都是原子性的，不可再分**

不符合1NF的例子：

```sql
-- 不符合1NF：地址字段包含多个值
CREATE TABLE customer_bad (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    address VARCHAR(255) COMMENT '完整地址: 省市区街道门牌号'
);
```

符合1NF的设计：

```sql
-- 符合1NF：地址拆分为原子字段
CREATE TABLE customer_1nf (
    id INT PRIMARY KEY COMMENT '客户ID',
    name VARCHAR(100) COMMENT '客户名称',
    province VARCHAR(50) COMMENT '省份',
    city VARCHAR(50) COMMENT '城市',
    district VARCHAR(50) COMMENT '区县',
    street VARCHAR(100) COMMENT '街道',
    address_detail VARCHAR(100) COMMENT '详细地址'
) COMMENT '客户表-符合1NF';
```

### 4.2 第二范式（2NF）
**原则：满足1NF，并且每个非主键字段完全依赖于主键**

不符合2NF的例子：

```sql
-- 不符合2NF：产品信息只依赖于product_id，不完全依赖组合主键
CREATE TABLE order_detail_bad (
    order_id INT,
    product_id INT,
    product_name VARCHAR(100) COMMENT '产品名称（只依赖product_id）',
    product_price DECIMAL(10,2) COMMENT '产品价格（只依赖product_id）',
    quantity INT COMMENT '数量',
    PRIMARY KEY (order_id, product_id)
) COMMENT '订单明细表-不符合2NF';
```

符合2NF的设计：

```sql
-- 产品表：存储产品信息
CREATE TABLE products_2nf (
    id INT PRIMARY KEY COMMENT '产品ID',
    name VARCHAR(100) COMMENT '产品名称',
    price DECIMAL(10,2) COMMENT '产品价格'
) COMMENT '产品表-符合2NF';

-- 订单明细表：只保留完全依赖组合主键的字段
CREATE TABLE order_details_2nf (
    order_id INT COMMENT '订单ID',
    product_id INT COMMENT '产品ID',
    quantity INT COMMENT '数量',
    actual_price DECIMAL(10,2) COMMENT '实际单价（可能与产品表价格不同）',
    PRIMARY KEY (order_id, product_id)
) COMMENT '订单明细表-符合2NF';
```

### 4.3 第三范式（3NF）
**原则：满足2NF，并且非主键字段不依赖于其他非主键字段**

不符合3NF的例子：

```sql
-- 不符合3NF：订单表中包含了客户信息（依赖于customer_id）
CREATE TABLE orders_bad (
    id INT PRIMARY KEY COMMENT '订单ID',
    customer_id INT COMMENT '客户ID',
    customer_name VARCHAR(100) COMMENT '客户姓名（依赖customer_id）',
    customer_phone VARCHAR(20) COMMENT '客户电话（依赖customer_id）',
    total_amount DECIMAL(10,2) COMMENT '订单总金额'
) COMMENT '订单表-不符合3NF';
```

符合3NF的设计：

```sql
-- 客户表：独立存储客户信息
CREATE TABLE customers_3nf (
    id INT PRIMARY KEY COMMENT '客户ID',
    name VARCHAR(100) COMMENT '客户姓名',
    phone VARCHAR(20) COMMENT '客户电话'
) COMMENT '客户表-符合3NF';

-- 订单表：只引用客户ID
CREATE TABLE orders_3nf (
    id INT PRIMARY KEY COMMENT '订单ID',
    customer_id INT COMMENT '客户ID',
    total_amount DECIMAL(10,2) COMMENT '订单总金额',
    FOREIGN KEY (customer_id) REFERENCES customers_3nf(id)
) COMMENT '订单表-符合3NF';
```

### 4.4 反规范化考虑
在某些情况下，适当的反规范化可以提高性能。

反规范化示例：

```sql
-- 在订单表中冗余存储部分客户信息，提高查询效率
CREATE TABLE orders_denormalized (
    id INT PRIMARY KEY COMMENT '订单ID',
    customer_id INT COMMENT '客户ID',
    customer_name VARCHAR(100) COMMENT '下单时的客户姓名（冗余）',
    customer_phone VARCHAR(20) COMMENT '下单时的联系电话（冗余）',
    total_amount DECIMAL(10,2) COMMENT '订单总金额',
    items_count INT COMMENT '商品总数量（冗余）',
    created_at TIMESTAMP COMMENT '创建时间'
) COMMENT '订单表-反规范化';
```

**反规范化考虑因素**：

1. 读写比例：读多写少的场景更适合反规范化
2. 查询性能：反规范化可减少多表联接，提高查询速度
3. 数据一致性：反规范化增加了数据不一致的风险
4. 典型应用场景：
    - 冗余存储常用统计值（如订单商品总数）
    - 冗余存储关联表的名称等描述性字段
    - 冗余存储变更不频繁的主数据

## 实战案例：电商系统数据库设计
下面是一个简化的电商系统数据库设计示例，综合应用前面的设计原则：

```sql
-- 用户表
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID，自增主键',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名，唯一',
    password VARCHAR(100) NOT NULL COMMENT '密码，加密存储',
    email VARCHAR(100) UNIQUE COMMENT '邮箱，唯一',
    phone VARCHAR(20) UNIQUE COMMENT '手机号，唯一',
    real_name VARCHAR(50) COMMENT '真实姓名',
    id_card VARCHAR(18) COMMENT '身份证号',
    avatar VARCHAR(255) COMMENT '头像URL',
    gender TINYINT COMMENT '性别：0未知，1男，2女',
    birthday DATE COMMENT '生日',
    status TINYINT DEFAULT 1 COMMENT '状态：0禁用，1正常',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_phone (phone) COMMENT '手机号索引',
    INDEX idx_email (email) COMMENT '邮箱索引'
) COMMENT '用户表';

-- 用户地址表
CREATE TABLE user_addresses (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '地址ID，自增主键',
    user_id INT NOT NULL COMMENT '用户ID',
    receiver VARCHAR(50) NOT NULL COMMENT '收货人姓名',
    phone VARCHAR(20) NOT NULL COMMENT '收货人电话',
    province VARCHAR(20) NOT NULL COMMENT '省份',
    city VARCHAR(20) NOT NULL COMMENT '城市',
    district VARCHAR(20) NOT NULL COMMENT '区/县',
    detail VARCHAR(200) NOT NULL COMMENT '详细地址',
    is_default TINYINT DEFAULT 0 COMMENT '是否默认地址：0否，1是',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_user_id (user_id) COMMENT '用户ID索引',
    CONSTRAINT fk_address_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE
) COMMENT '用户地址表';

-- 商品分类表
CREATE TABLE product_categories (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '分类ID，自增主键',
    parent_id INT DEFAULT 0 COMMENT '父分类ID，0表示一级分类',
    name VARCHAR(50) NOT NULL COMMENT '分类名称',
    level TINYINT NOT NULL COMMENT '分类级别：1一级，2二级，3三级',
    sort INT DEFAULT 0 COMMENT '排序值，越大越靠前',
    icon VARCHAR(255) COMMENT '分类图标URL',
    status TINYINT DEFAULT 1 COMMENT '状态：0禁用，1启用',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_parent_id (parent_id) COMMENT '父分类索引',
    INDEX idx_level (level) COMMENT '分类级别索引'
) COMMENT '商品分类表';

-- 商品表
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '商品ID，自增主键',
    category_id INT NOT NULL COMMENT '分类ID',
    name VARCHAR(100) NOT NULL COMMENT '商品名称',
    subtitle VARCHAR(200) COMMENT '副标题/卖点',
    main_image VARCHAR(255) COMMENT '主图URL',
    detail TEXT COMMENT '商品详情',
    price DECIMAL(10,2) NOT NULL COMMENT '销售价格',
    market_price DECIMAL(10,2) COMMENT '市场价/原价',
    stock INT NOT NULL DEFAULT 0 COMMENT '库存数量',
    status TINYINT DEFAULT 1 COMMENT '状态：0下架，1上架',
    sales INT DEFAULT 0 COMMENT '销量',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_category (category_id) COMMENT '分类索引',
    INDEX idx_name (name) COMMENT '商品名称索引',
    CONSTRAINT fk_product_category FOREIGN KEY (category_id) REFERENCES product_categories(id)
) COMMENT '商品表';

-- 商品图片表
CREATE TABLE product_images (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '图片ID，自增主键',
    product_id INT NOT NULL COMMENT '商品ID',
    image_url VARCHAR(255) NOT NULL COMMENT '图片URL',
    sort INT DEFAULT 0 COMMENT '排序，越大越靠前',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX idx_product_id (product_id) COMMENT '商品ID索引',
    CONSTRAINT fk_image_product FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE ON UPDATE CASCADE
) COMMENT '商品图片表';

-- 订单表
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID，自增主键',
    order_no VARCHAR(20) NOT NULL UNIQUE COMMENT '订单编号，唯一',
    user_id INT NOT NULL COMMENT '用户ID',
    shipping_id INT COMMENT '收货地址ID',
    payment_amount DECIMAL(10,2) NOT NULL COMMENT '实付金额',
    freight_amount DECIMAL(6,2) NOT NULL DEFAULT 0.00 COMMENT '运费',
    discount_amount DECIMAL(6,2) NOT NULL DEFAULT 0.00 COMMENT '优惠金额',
    order_status TINYINT NOT NULL DEFAULT 1 COMMENT '订单状态：1待付款，2已付款待发货，3已发货，4已完成，5已取消',
    payment_method TINYINT COMMENT '支付方式：1微信，2支付宝',
    payment_time DATETIME COMMENT '支付时间',
    shipping_time DATETIME COMMENT '发货时间',
    completion_time DATETIME COMMENT '完成时间',
    cancel_time DATETIME COMMENT '取消时间',
    cancel_reason VARCHAR(200) COMMENT '取消原因',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_user_id (user_id) COMMENT '用户ID索引',
    INDEX idx_order_no (order_no) COMMENT '订单编号索引',
    INDEX idx_order_status (order_status) COMMENT '订单状态索引',
    CONSTRAINT fk_order_user FOREIGN KEY (user_id) REFERENCES users(id)
) COMMENT '订单表';

-- 订单明细表
CREATE TABLE order_items (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '明细ID，自增主键',
    order_id INT NOT NULL COMMENT '订单ID',
    product_id INT NOT NULL COMMENT '商品ID',
    product_name VARCHAR(100) NOT NULL COMMENT '商品名称（快照）',
    product_image VARCHAR(255) COMMENT '商品图片（快照）',
    current_price DECIMAL(10,2) NOT NULL COMMENT '购买时单价（快照）',
    quantity INT NOT NULL COMMENT '购买数量',
    total_price DECIMAL(10,2) NOT NULL COMMENT '总价=单价*数量',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX idx_order_id (order_id) COMMENT '订单ID索引',
    INDEX idx_product_id (product_id) COMMENT '商品ID索引',
    CONSTRAINT fk_item_order FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_item_product FOREIGN KEY (product_id) REFERENCES products(id)
) COMMENT '订单明细表';

-- 购物车表
CREATE TABLE cart_items (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '购物车项ID，自增主键',
    user_id INT NOT NULL COMMENT '用户ID',
    product_id INT NOT NULL COMMENT '商品ID',
    quantity INT NOT NULL COMMENT '数量',
    checked TINYINT DEFAULT 1 COMMENT '是否选中：0未选中，1选中',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    UNIQUE KEY uk_user_product (user_id, product_id) COMMENT '用户ID和商品ID唯一索引',
    INDEX idx_user_id (user_id) COMMENT '用户ID索引',
    CONSTRAINT fk_cart_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_cart_product FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE ON UPDATE CASCADE
) COMMENT '购物车表';
```

这个设计遵循了前面讨论的数据库设计原则：

1. **规范命名**：所有表名和字段名使用小写字母和下划线分隔
2. **合理的主键**：使用自增整数作为主键，提高性能
3. **适当的外键**：使用外键确保引用完整性
4. **详细的注释**：每个表和字段都有明确的注释
5. **规范化设计**：遵循第三范式，减少数据冗余
6. **适当的冗余**：在订单明细表中保存商品名称等快照数据
7. **合理的索引**：为常用查询字段创建索引

## 5. 索引设计
索引是提高查询性能的关键技术，但也会增加写入开销。

### 5.1 索引类型
```sql
-- 创建带有各种索引的表
CREATE TABLE products_with_indexes (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '商品ID，自增主键',
    sku VARCHAR(50) NOT NULL COMMENT '商品编码',
    name VARCHAR(100) NOT NULL COMMENT '商品名称',
    category_id INT NOT NULL COMMENT '分类ID',
    brand_id INT COMMENT '品牌ID',
    price DECIMAL(10,2) NOT NULL COMMENT '商品价格',
    description TEXT COMMENT '商品描述',
    tags VARCHAR(255) COMMENT '商品标签，多个标签用逗号分隔',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    -- 唯一索引（也称为唯一键）
    UNIQUE INDEX uk_sku (sku) COMMENT 'SKU唯一索引',
    
    -- 普通单列索引
    INDEX idx_name (name) COMMENT '商品名称索引',
    
    -- 复合索引（多列索引）
    INDEX idx_category_brand (category_id, brand_id) COMMENT '分类和品牌复合索引',
    
    -- 前缀索引（适用于长文本字段）
    INDEX idx_tags (tags(50)) COMMENT '标签前50个字符的索引',
    
    -- 全文索引
    FULLTEXT INDEX ft_description (description) COMMENT '商品描述全文索引'
) COMMENT '带索引的商品表';
```

**索引类型说明**：

1. **主键索引**：PRIMARY KEY，唯一标识记录的索引
2. **唯一索引**：UNIQUE INDEX，保证字段值唯一性的索引
3. **普通索引**：INDEX，提高查询效率的一般索引
4. **复合索引**：包含多个列的索引，遵循最左前缀原则
5. **前缀索引**：只索引字符串的前N个字符，节省空间
6. **全文索引**：FULLTEXT INDEX，用于全文搜索

### 5.2 索引设计原则
```sql
-- 为查询频繁的热门商品表创建合理索引
CREATE TABLE hot_products (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '商品ID，自增主键',
    name VARCHAR(100) NOT NULL COMMENT '商品名称',
    category_id INT NOT NULL COMMENT '分类ID',
    price DECIMAL(10,2) NOT NULL COMMENT '价格',
    stock INT NOT NULL DEFAULT 0 COMMENT '库存',
    sales INT NOT NULL DEFAULT 0 COMMENT '销量',
    rating DECIMAL(3,1) NOT NULL DEFAULT 5.0 COMMENT '评分：1-5分',
    status TINYINT NOT NULL DEFAULT 1 COMMENT '状态：0下架，1上架',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    
    -- 为常用查询条件创建索引
    INDEX idx_category_status (category_id, status) COMMENT '分类和状态复合索引',
    INDEX idx_price (price) COMMENT '价格索引',
    INDEX idx_sales_rating (sales, rating) COMMENT '销量和评分复合索引'
) COMMENT '热门商品表';
```

**索引设计原则**：

1. **为WHERE条件字段创建索引**：经常用于筛选的字段应建索引
2. **为JOIN条件字段创建索引**：表连接的字段（如外键）需要索引
3. **为ORDER BY字段创建索引**：排序字段建索引可避免文件排序
4. **遵循最左前缀原则**：复合索引查询条件要包含最左侧字段
5. **选择性原则**：索引区分度高的字段（唯一值比例高）更适合建索引
6. **避免过多索引**：每个表的索引数量建议控制在5个以内
7. **避免冗余索引**：如已有(a,b)索引，就不需要单独的(a)索引
8. **小表不建索引**：数据量小的表全表扫描可能更快

### 5.3 添加和优化索引
```sql
-- 在已有表上添加索引
ALTER TABLE orders 
ADD INDEX idx_create_status (created_at, order_status) COMMENT '创建时间和订单状态复合索引';

-- 删除不必要的索引
ALTER TABLE products
DROP INDEX idx_redundant;

-- 修改已有索引
ALTER TABLE products
DROP INDEX idx_old,
ADD INDEX idx_new (field1, field2);

-- 查看表的索引
SHOW INDEX FROM products;
```

**索引管理说明**：

1. 添加索引方式：
    - 创建表时定义索引
    - 使用ALTER TABLE添加索引
    - 使用CREATE INDEX语句（实际是ALTER TABLE的别名）
2. 索引命名规范：
    - 主键索引：默认名称为PRIMARY
    - 唯一索引：uk_表名_字段名
    - 普通索引：idx_表名_字段名
    - 全文索引：ft_表名_字段名
3. 分析索引使用情况：

```sql
-- 查看查询的执行计划
EXPLAIN SELECT * FROM products WHERE category_id = 1 AND price > 100;

-- 查看索引使用统计
SHOW INDEX FROM products;
```

## 6. 实战案例：数据库性能优化
在实际项目中，数据库设计不仅要考虑表结构和规范化，还要考虑性能和可扩展性。

### 6.1 表分区
```sql
-- 创建按年月分区的订单历史表
CREATE TABLE order_history (
    id INT NOT NULL COMMENT '订单ID',
    order_no VARCHAR(20) NOT NULL COMMENT '订单编号',
    user_id INT NOT NULL COMMENT '用户ID',
    payment_amount DECIMAL(10,2) NOT NULL COMMENT '支付金额',
    order_status TINYINT NOT NULL COMMENT '订单状态',
    created_at TIMESTAMP NOT NULL COMMENT '创建时间',
    PRIMARY KEY (id, created_at),
    INDEX idx_created_at (created_at)
) COMMENT '订单历史表'
PARTITION BY RANGE (UNIX_TIMESTAMP(created_at)) (
    PARTITION p_2021_01 VALUES LESS THAN (UNIX_TIMESTAMP('2021-02-01 00:00:00')),
    PARTITION p_2021_02 VALUES LESS THAN (UNIX_TIMESTAMP('2021-03-01 00:00:00')),
    PARTITION p_2021_03 VALUES LESS THAN (UNIX_TIMESTAMP('2021-04-01 00:00:00')),
    PARTITION p_2021_04 VALUES LESS THAN (UNIX_TIMESTAMP('2021-05-01 00:00:00')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**表分区说明**：

1. 分区的好处：
    - 提高大表查询性能（可以只扫描相关分区）
    - 简化数据归档（可以直接移除整个分区）
    - 跨磁盘分布数据（提高I/O并行度）
2. 常见分区类型：
    - RANGE分区：基于连续范围（如日期）
    - LIST分区：基于离散值列表（如国家代码）
    - HASH分区：基于哈希函数（均匀分布）
    - KEY分区：类似HASH，但使用MySQL自己的哈希函数
3. 分区限制：
    - 分区字段必须是主键的一部分
    - 每个表最多1024个分区
    - 不能使用外键约束

### 6.2 垂直分表
垂直分表是将一个表按列分成多个表，每个表存储部分字段。

```sql
-- 原始产品表（包含所有字段）
CREATE TABLE products_original (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '商品ID',
    name VARCHAR(100) NOT NULL COMMENT '商品名称',
    price DECIMAL(10,2) NOT NULL COMMENT '价格',
    stock INT NOT NULL DEFAULT 0 COMMENT '库存',
    category_id INT NOT NULL COMMENT '分类ID',
    image VARCHAR(255) COMMENT '主图',
    description TEXT COMMENT '商品描述',
    specifications TEXT COMMENT '规格参数',
    packing_list TEXT COMMENT '包装清单',
    service_guarantee TEXT COMMENT '售后保证',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间'
) COMMENT '商品表-未拆分';

-- 垂直分表后 - 核心信息表（高频访问字段）
CREATE TABLE products_core (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '商品ID',
    name VARCHAR(100) NOT NULL COMMENT '商品名称',
    price DECIMAL(10,2) NOT NULL COMMENT '价格',
    stock INT NOT NULL DEFAULT 0 COMMENT '库存',
    category_id INT NOT NULL COMMENT '分类ID',
    image VARCHAR(255) COMMENT '主图',
    status TINYINT DEFAULT 1 COMMENT '状态：0下架，1上架',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_category (category_id) COMMENT '分类索引'
) COMMENT '商品核心信息表';

-- 垂直分表后 - 详情表（低频访问的大文本字段）
CREATE TABLE product_details (
    product_id INT PRIMARY KEY COMMENT '商品ID',
    description TEXT COMMENT '商品描述',
    specifications TEXT COMMENT '规格参数',
    packing_list TEXT COMMENT '包装清单',
    service_guarantee TEXT COMMENT '售后保证',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    CONSTRAINT fk_detail_product FOREIGN KEY (product_id) REFERENCES products_core(id) ON DELETE CASCADE ON UPDATE CASCADE
) COMMENT '商品详情表';
```

**垂直分表说明**：

1. 垂直分表原则：
    - 将经常一起使用的字段放在同一个表中
    - 将大字段和不常用字段分离出去
    - 核心表保持较小规模，提高缓存命中率
2. 垂直分表优势：
    - 减小表的宽度，提高查询性能
    - 减少I/O操作，节省磁盘和内存空间
    - 针对性缓存热点数据
3. 实施建议：
    - 保持主键一致，便于关联
    - 考虑数据一致性问题
    - 根据访问频率和字段大小决定拆分方案

### 6.3 水平分表
水平分表是将一个表的数据按行分成多个表，每个表结构相同但数据不同。

```sql
-- 按用户ID范围水平拆分用户表
CREATE TABLE users_0000_1000 (
    id INT PRIMARY KEY COMMENT '用户ID：0-1000范围',
    username VARCHAR(50) NOT NULL COMMENT '用户名',
    email VARCHAR(100) COMMENT '邮箱',
    -- 其他字段与原表相同
    CHECK (id >= 0 AND id < 1000)
) COMMENT '用户表分片0-1000';

CREATE TABLE users_1000_2000 (
    id INT PRIMARY KEY COMMENT '用户ID：1000-2000范围',
    username VARCHAR(50) NOT NULL COMMENT '用户名',
    email VARCHAR(100) COMMENT '邮箱',
    -- 其他字段与原表相同
    CHECK (id >= 1000 AND id < 2000)
) COMMENT '用户表分片1000-2000';

-- 按订单创建时间水平拆分订单表
CREATE TABLE orders_2021 (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID',
    order_no VARCHAR(20) NOT NULL COMMENT '订单编号',
    user_id INT NOT NULL COMMENT '用户ID',
    -- 其他字段与原表相同
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    CHECK (created_at >= '2021-01-01' AND created_at < '2022-01-01')
) COMMENT '2021年订单表';

CREATE TABLE orders_2022 (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID',
    order_no VARCHAR(20) NOT NULL COMMENT '订单编号',
    user_id INT NOT NULL COMMENT '用户ID',
    -- 其他字段与原表相同
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    CHECK (created_at >= '2022-01-01' AND created_at < '2023-01-01')
) COMMENT '2022年订单表';
```

**水平分表说明**：

1. 水平分表策略：
    - 按ID范围分片：简单但可能导致数据分布不均
    - 按时间分片：适合历史数据，便于归档
    - 按哈希分片：数据分布均匀，但扩容复杂
2. 水平分表优势：
    - 减小单表数据量，提高查询性能
    - 分散数据库I/O压力
    - 便于数据库扩展
3. 实施挑战：
    - 需要分片路由逻辑（应用层或中间件）
    - 跨分片查询复杂
    - 自增主键处理复杂
    - 分布式事务问题

在实际项目中，通常会使用专门的数据库中间件（如ShardingSphere、MyCat等）来实现水平分表，而不是手动维护。

## 7. 综合实战案例：电商平台数据库优化设计
下面是一个综合考虑了性能优化的电商平台数据库设计示例：

```sql
-- 用户核心信息表（高频访问）
CREATE TABLE users_core (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    password VARCHAR(100) NOT NULL COMMENT '密码哈希',
    email VARCHAR(100) UNIQUE COMMENT '邮箱',
    phone VARCHAR(20) UNIQUE COMMENT '手机号',
    status TINYINT DEFAULT 1 COMMENT '状态：0禁用，1正常',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间',
    INDEX idx_phone (phone) COMMENT '手机号索引',
    INDEX idx_email (email) COMMENT '邮箱索引'
) COMMENT '用户核心信息表' PARTITION BY HASH(id) PARTITIONS 4;

-- 用户扩展信息表（低频访问）
CREATE TABLE user_profiles (
    user_id INT PRIMARY KEY COMMENT '用户ID',
    real_name VARCHAR(50) COMMENT '真实姓名',
    gender TINYINT COMMENT '性别：0未知，1男，2女',
    birthday DATE COMMENT '生日',
    avatar VARCHAR(255) COMMENT '头像URL',
    bio TEXT COMMENT '个人简介',
    last_login_time DATETIME COMMENT '最后登录时间',
    last_login_ip VARCHAR(50) COMMENT '最后登录IP',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    CONSTRAINT fk_profile_user FOREIGN KEY (user_id) REFERENCES users_core(id) ON DELETE CASCADE ON UPDATE CASCADE
) COMMENT '用户扩展信息表';

-- 商品表（优化索引和字段顺序）
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '商品ID',
    category_id INT NOT NULL COMMENT '分类ID',
    name VARCHAR(100) NOT NULL COMMENT '商品名称',
    price DECIMAL(10,2) NOT NULL COMMENT '销售价格',
    stock INT NOT NULL DEFAULT 0 COMMENT '库存数量',
    sales INT NOT NULL DEFAULT 0 COMMENT '销量',
    status TINYINT DEFAULT 1 COMMENT '状态：0下架，1上架',
    main_image VARCHAR(255) COMMENT '主图URL',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    -- 复合索引优化常见查询
    INDEX idx_cat_status_price (category_id, status, price) COMMENT '分类+状态+价格复合索引',
    INDEX idx_sales (sales) COMMENT '销量索引'
) COMMENT '商品表';

-- 商品详情表（大文本字段分离）
CREATE TABLE product_details (
    product_id INT PRIMARY KEY COMMENT '商品ID',
    description TEXT COMMENT '商品详情描述',
    specifications TEXT COMMENT '规格参数',
    features TEXT COMMENT '产品特点',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    CONSTRAINT fk_detail_product FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE ON UPDATE CASCADE
) COMMENT '商品详情表';

-- 订单表（按时间分区）
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID',
    order_no VARCHAR(20) NOT NULL UNIQUE COMMENT '订单编号',
    user_id INT NOT NULL COMMENT '用户ID',
    payment_amount DECIMAL(10,2) NOT NULL COMMENT '实付金额',
    order_status TINYINT NOT NULL DEFAULT 1 COMMENT '订单状态',
    payment_method TINYINT COMMENT '支付方式',
    shipping_address JSON COMMENT '收货地址（JSON格式）',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_user_id (user_id) COMMENT '用户ID索引',
    INDEX idx_create_status (created_at, order_status) COMMENT '创建时间和状态复合索引'
) COMMENT '订单表'
PARTITION BY RANGE (UNIX_TIMESTAMP(created_at)) (
    PARTITION p_2023_q1 VALUES LESS THAN (UNIX_TIMESTAMP('2023-04-01 00:00:00')),
    PARTITION p_2023_q2 VALUES LESS THAN (UNIX_TIMESTAMP('2023-07-01 00:00:00')),
    PARTITION p_2023_q3 VALUES LESS THAN (UNIX_TIMESTAMP('2023-10-01 00:00:00')),
    PARTITION p_2023_q4 VALUES LESS THAN (UNIX_TIMESTAMP('2024-01-01 00:00:00')),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);

-- 订单明细表
CREATE TABLE order_items (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '明细ID',
    order_id INT NOT NULL COMMENT '订单ID',
    product_id INT NOT NULL COMMENT '商品ID',
    product_name VARCHAR(100) NOT NULL COMMENT '商品名称（快照）',
    product_image VARCHAR(255) COMMENT '商品图片（快照）',
    quantity INT NOT NULL COMMENT '购买数量',
    price DECIMAL(10,2) NOT NULL COMMENT '购买单价（快照）',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX idx_order_id (order_id) COMMENT '订单ID索引',
    INDEX idx_product_id (product_id) COMMENT '商品ID索引'
) COMMENT '订单明细表';

-- 商品评价表（按商品ID分片）
CREATE TABLE product_reviews (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '评价ID',
    product_id INT NOT NULL COMMENT '商品ID',
    user_id INT NOT NULL COMMENT '用户ID',
    order_id INT COMMENT '订单ID',
    rating TINYINT NOT NULL COMMENT '评分：1-5星',
    content TEXT COMMENT '评价内容',
    images JSON COMMENT '评价图片URLs（JSON数组）',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX idx_product_id (product_id) COMMENT '商品ID索引',
    INDEX idx_user_id (user_id) COMMENT '用户ID索引'
) COMMENT '商品评价表' PARTITION BY HASH(product_id) PARTITIONS 8;

-- 用户登录记录表（只保留近期记录）
CREATE TABLE user_logins (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '记录ID',
    user_id INT NOT NULL COMMENT '用户ID',
    login_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '登录时间',
    login_ip VARCHAR(50) NOT NULL COMMENT '登录IP',
    device_type VARCHAR(20) COMMENT '设备类型',
    INDEX idx_user_time (user_id, login_time) COMMENT '用户ID和登录时间复合索引'
) COMMENT '用户登录记录表'
PARTITION BY RANGE (UNIX_TIMESTAMP(login_time)) (
    PARTITION p_last_month VALUES LESS THAN (UNIX_TIMESTAMP(DATE_SUB(CURRENT_DATE(), INTERVAL 1 MONTH))),
    PARTITION p_current VALUES LESS THAN MAXVALUE
);
```

**优化设计要点**：

1. **垂直分表**：将用户信息和商品信息分成核心表和扩展表
2. **表分区**：订单表按时间分区，用户表按ID分区
3. **JSON字段**：使用JSON类型存储灵活结构（如地址、图片列表）
4. **复合索引优化**：为常见查询场景设计优化的复合索引
5. **数据快照**：订单明细表保存商品信息快照，避免关联查询
6. **时间戳**：每个表包含created_at和updated_at字段，便于数据分析和问题排查
7. **合理的分表策略**：按访问频率和数据量拆分表

通过这些优化设计，数据库可以更好地支持高并发、大数据量的电商业务，同时保持良好的可维护性和数据一致性。

## 课程总结
在数据库设计部分，我们学习了：

1. 表设计规范：命名、类型选择、字段设计原则
2. 主键和外键：设计原则和使用场景
3. 约束条件：确保数据完整性和一致性
4. 规范化设计：减少数据冗余，提高数据质量
5. 索引设计：提高查询性能的关键技术
6. 性能优化：分区、垂直分表和水平分表策略

良好的数据库设计是构建高效、可靠应用系统的基础。在实际项目中，需要根据具体业务场景和性能需求，灵活应用这些设计原则，找到规范化和性能之间的平衡点。



> 更新: 2025-04-23 20:21:50  
> 原文: <https://www.yuque.com/linuxer/gscfv1/xifg3reocr94tr7k>