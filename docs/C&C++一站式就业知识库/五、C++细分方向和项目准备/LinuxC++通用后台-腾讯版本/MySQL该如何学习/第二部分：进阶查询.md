# 第二部分：进阶查询

在第二部分中，我们将基于第一部分创建的电商数据库进行进阶查询操作。首先，让我们完善数据库结构并添加更多测试数据。

# 1. 完善数据库结构
首先，让我们创建更完整的电商数据库表结构（所有表和字段都带有详细注释）：

```sql
-- 使用之前创建的数据库
USE myshop;

-- 如果之前的表已存在，可以先删除
DROP TABLE IF EXISTS order_items;
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS product_categories;
DROP TABLE IF EXISTS users;

-- 创建用户表
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户ID，自增主键',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名，唯一，用于登录',
    password VARCHAR(100) NOT NULL COMMENT '用户密码，加密存储',
    email VARCHAR(100) UNIQUE COMMENT '用户邮箱，唯一标识',
    phone VARCHAR(20) COMMENT '用户手机号码',
    address TEXT COMMENT '用户收货地址',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '账号创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后更新时间'
) COMMENT '用户信息表';

-- 创建商品分类表
CREATE TABLE product_categories (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '分类ID，自增主键',
    name VARCHAR(50) NOT NULL UNIQUE COMMENT '分类名称，唯一',
    parent_id INT DEFAULT NULL COMMENT '父分类ID，用于构建分类树，NULL表示顶级分类',
    level INT DEFAULT 1 COMMENT '分类层级，1表示一级分类，2表示二级分类，以此类推',
    sort_order INT DEFAULT 0 COMMENT '排序值，数值越大越靠前',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'
) COMMENT '商品分类表';

-- 创建商品表
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '商品ID，自增主键',
    category_id INT NOT NULL COMMENT '所属分类ID，关联product_categories表',
    name VARCHAR(100) NOT NULL COMMENT '商品名称，不可为空',
    price DECIMAL(10,2) NOT NULL COMMENT '商品售价，精确到分',
    original_price DECIMAL(10,2) COMMENT '商品原价，用于显示折扣',
    description TEXT COMMENT '商品详细描述',
    stock INT DEFAULT 0 COMMENT '库存数量，默认为0',
    status TINYINT DEFAULT 1 COMMENT '商品状态：0-下架，1-上架',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '商品创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后更新时间'
) COMMENT '商品信息表';

-- 创建订单表
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单ID，自增主键',
    order_no VARCHAR(20) NOT NULL UNIQUE COMMENT '订单编号，唯一',
    user_id INT NOT NULL COMMENT '下单用户ID，关联users表',
    payment_amount DECIMAL(10,2) NOT NULL COMMENT '实付金额，精确到分',
    payment_method TINYINT COMMENT '支付方式：1-微信，2-支付宝，3-银行卡',
    payment_time DATETIME COMMENT '支付时间',
    shipping_address TEXT NOT NULL COMMENT '收货地址，JSON格式储存',
    order_status TINYINT DEFAULT 1 COMMENT '订单状态：1-待付款，2-已付款待发货，3-已发货，4-已完成，5-已取消',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '下单时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后更新时间'
) COMMENT '订单主表';

-- 创建订单详情表
CREATE TABLE order_items (
    id INT AUTO_INCREMENT PRIMARY KEY COMMENT '订单项ID，自增主键',
    order_id INT NOT NULL COMMENT '所属订单ID，关联orders表',
    product_id INT NOT NULL COMMENT '购买商品ID，关联products表',
    product_name VARCHAR(100) NOT NULL COMMENT '下单时的商品名称（快照）',
    quantity INT NOT NULL COMMENT '购买数量',
    price DECIMAL(10,2) NOT NULL COMMENT '购买时的商品单价（快照），精确到分'
) COMMENT '订单详情表';
```

# 2. 插入测试数据
以下是为进阶查询准备的测试数据：

```sql
-- 插入用户数据
INSERT INTO users (username, password, email, phone, address) VALUES 
    ('张三', 'e10adc3949ba59abbe56e057f20f883e', 'zhangsan@example.com', '13800138001', '北京市朝阳区某小区1号楼1单元101'),
    ('李四', 'e10adc3949ba59abbe56e057f20f883e', 'lisi@example.com', '13800138002', '上海市浦东新区某小区2号楼2单元202'),
    ('王五', 'e10adc3949ba59abbe56e057f20f883e', 'wangwu@example.com', '13800138003', '广州市天河区某小区3号楼3单元303'),
    ('赵六', 'e10adc3949ba59abbe56e057f20f883e', 'zhaoliu@example.com', '13800138004', '深圳市南山区某小区4号楼4单元404'),
    ('钱七', 'e10adc3949ba59abbe56e057f20f883e', 'qianqi@example.com', '13800138005', '杭州市西湖区某小区5号楼5单元505');

-- 插入商品分类数据
INSERT INTO product_categories (name, parent_id, level, sort_order) VALUES 
    ('电子产品', NULL, 1, 100),
    ('服装鞋帽', NULL, 1, 90),
    ('食品饮料', NULL, 1, 80),
    ('家居用品', NULL, 1, 70),
    ('手机数码', 1, 2, 100),
    ('电脑办公', 1, 2, 90),
    ('智能设备', 1, 2, 80),
    ('男装', 2, 2, 100),
    ('女装', 2, 2, 90),
    ('鞋靴', 2, 2, 80);

-- 插入商品数据
INSERT INTO products (category_id, name, price, original_price, description, stock, status) VALUES 
    (5, 'iPhone 13', 5999.00, 6299.00, 'Apple最新款智能手机，搭载A15处理器', 100, 1),
    (5, '华为 Mate 40 Pro', 6499.00, 6999.00, '华为旗舰智能手机，搭载麒麟9000处理器', 50, 1),
    (5, '小米12', 4299.00, 4599.00, '小米最新旗舰，搭载骁龙8处理器', 200, 1),
    (6, 'MacBook Pro', 12999.00, 13999.00, 'Apple专业笔记本电脑，搭载M1芯片', 30, 1),
    (6, '联想ThinkPad', 8999.00, 9599.00, '商务办公笔记本电脑', 40, 1),
    (6, '华硕ROG电竞本', 9999.00, 10999.00, '高性能游戏笔记本', 20, 1),
    (7, 'Apple Watch', 2999.00, 3299.00, 'Apple智能手表，健康监测', 150, 1),
    (7, '小米手环', 249.00, 299.00, '智能健康手环，长续航', 500, 1),
    (8, '男士休闲夹克', 499.00, 599.00, '秋冬新款，保暖舒适', 200, 1),
    (8, '男士牛仔裤', 299.00, 399.00, '时尚百搭，舒适耐穿', 300, 1),
    (9, '女士羽绒服', 899.00, 1099.00, '冬季保暖长款羽绒服', 100, 1),
    (9, '女士连衣裙', 459.00, 599.00, '春夏新款，清新淑女', 150, 1);

-- 插入订单数据
INSERT INTO orders (order_no, user_id, payment_amount, payment_method, payment_time, shipping_address, order_status) VALUES 
    ('2022040100001', 1, 6248.00, 1, '2022-04-01 10:15:20', '北京市朝阳区某小区1号楼1单元101', 4),
    ('2022040200001', 2, 12999.00, 2, '2022-04-02 14:30:00', '上海市浦东新区某小区2号楼2单元202', 3),
    ('2022040300001', 3, 249.00, 1, NULL, '广州市天河区某小区3号楼3单元303', 1),
    ('2022040400001', 1, 899.00, 2, '2022-04-04 18:20:35', '北京市朝阳区某小区1号楼1单元101', 2),
    ('2022040500001', 4, 15998.00, 3, '2022-04-05 09:10:25', '深圳市南山区某小区4号楼4单元404', 3),
    ('2022040600001', 5, 798.00, 1, '2022-04-06 11:05:12', '杭州市西湖区某小区5号楼5单元505', 4);

-- 插入订单详情数据
INSERT INTO order_items (order_id, product_id, product_name, quantity, price) VALUES 
    (1, 1, 'iPhone 13', 1, 5999.00),
    (1, 8, '小米手环', 1, 249.00),
    (2, 4, 'MacBook Pro', 1, 12999.00),
    (3, 8, '小米手环', 1, 249.00),
    (4, 11, '女士羽绒服', 1, 899.00),
    (5, 3, '小米12', 2, 4299.00),
    (5, 6, '华硕ROG电竞本', 1, 9999.00),
    (6, 10, '男士牛仔裤', 2, 299.00),
    (6, 8, '小米手环', 1, 249.00);
```



# 3. 多表联接（JOIN）
## 3.1 内连接（INNER JOIN）
### 示例1：查询订单及其相关用户信息
```sql
SELECT o.order_no, o.payment_amount, u.username, u.phone
FROM orders o
INNER JOIN users u ON o.user_id = u.id;
```

**解释**：

+ 此查询连接了`orders`表和`users`表，使用了表别名`o`和`u`
+ `ON o.user_id = u.id`指定了连接条件：订单表的user_id与用户表的id匹配
+ 结果包含订单编号、支付金额、用户名和电话号码
+ 只返回在两个表中都有匹配数据的记录（即有订单的用户和有对应用户的订单）
+ 不会显示没有下订单的用户或没有对应用户的订单（如果存在）

### 示例2：查询已支付订单的商品详情
```sql
SELECT o.order_no, oi.product_name, oi.quantity, oi.price, (oi.quantity * oi.price) AS item_total
FROM orders o
INNER JOIN order_items oi ON o.id = oi.order_id
WHERE o.order_status >= 2;
```

**解释**：

+ 此查询连接了`orders`表和`order_items`表
+ `ON o.id = oi.order_id`指定连接条件：订单表的id与订单详情表的order_id匹配
+ `WHERE o.order_status >= 2`筛选条件：只查询状态为2及以上的订单（已支付的订单）
+ 结果显示订单编号、商品名称、购买数量、单价，以及计算出的小计金额
+ `(oi.quantity * oi.price) AS item_total`创建了一个计算字段，显示每个订单项的总金额

## 3.2 左连接（LEFT JOIN）
### 示例1：查询所有用户及其订单信息
```sql
SELECT u.username, u.email, o.order_no, o.payment_amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
```

**解释**：

+ 此查询将`users`作为左表，`orders`作为右表进行连接
+ 结果返回所有用户记录，即使用户没有下过订单
+ 对于没有订单的用户，订单相关字段（order_no, payment_amount）显示为NULL
+ 这种查询可以用来查找哪些用户从未下过订单

### 示例2：查询所有商品及其销售数量
```sql
SELECT p.name, p.price, IFNULL(SUM(oi.quantity), 0) AS sold_quantity
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
GROUP BY p.id, p.name, p.price;
```

**解释**：

+ 此查询将`products`作为左表，`order_items`作为右表进行连接
+ `GROUP BY p.id, p.name, p.price`按商品分组
+ `SUM(oi.quantity)`计算每个商品的销售总量
+ `IFNULL(SUM(oi.quantity), 0)`确保未售出商品的销售量显示为0而不是NULL
+ 结果包含所有商品，不管它们是否被销售过
+ 可用于分析商品销量情况，包括滞销商品

## 3.3 右连接（RIGHT JOIN）
### 示例：查询所有订单及对应用户
```sql
SELECT o.order_no, o.payment_amount, u.username, u.phone
FROM orders o
RIGHT JOIN users u ON o.user_id = u.id;
```

**解释**：

+ 此查询将`orders`作为左表，`users`作为右表进行连接
+ 结果返回所有用户记录，即使用户没有下过订单
+ 功能上与上面的LEFT JOIN示例1等价，只是表的顺序和JOIN类型不同
+ 在实际应用中，这个查询通常使用LEFT JOIN更直观，RIGHT JOIN在此处是为了演示语法

## 3.4 多表连接
### 示例1：查询订单、用户和订单项的完整信息
```sql
SELECT o.order_no, u.username, p.name AS product_name, 
       oi.quantity, oi.price, (oi.quantity * oi.price) AS item_total
FROM orders o
INNER JOIN users u ON o.user_id = u.id
INNER JOIN order_items oi ON o.id = oi.order_id
INNER JOIN products p ON oi.product_id = p.id
ORDER BY o.created_at DESC;
```

**解释**：

+ 此查询连接了四个表：`orders`、`users`、`order_items`和`products`
+ 连接路径：订单→用户、订单→订单项→商品
+ 第一个JOIN：将订单与用户关联，获取下单用户信息
+ 第二个JOIN：将订单与订单项关联，获取订单中包含的商品信息
+ 第三个JOIN：将订单项与商品关联，获取商品详情
+ `ORDER BY o.created_at DESC`按订单创建时间降序排列，最新订单显示在前
+ 结果显示完整的订单信息，包括订单号、用户名、商品名称、数量、单价和小计金额
+ 此查询适用于生成详细的订单报表或订单明细页面

### 示例2：查询商品及其所属分类（包括父分类）
```sql
SELECT p.name AS product_name, c.name AS category_name, 
       pc.name AS parent_category_name
FROM products p
INNER JOIN product_categories c ON p.category_id = c.id
LEFT JOIN product_categories pc ON c.parent_id = pc.id;
```

**解释**：

+ 此查询连接了`products`表和`product_categories`表两次
+ 第一个JOIN（INNER JOIN）：将商品与其直接分类关联
+ 第二个JOIN（LEFT JOIN）：将直接分类与父分类关联
+ 使用LEFT JOIN是因为顶级分类没有父分类（parent_id为NULL）
+ 结果显示商品名称、直接分类名称和父分类名称（如果有）
+ 对于属于顶级分类的商品，parent_category_name字段显示为NULL
+ 此查询可用于显示商品的完整分类路径，便于导航和筛选

这些JOIN查询示例展示了如何通过表连接从多个相关表中获取综合信息。JOIN是SQL中非常强大的功能，掌握不同类型的JOIN及其适用场景对于编写高效的数据库查询至关重要。

 

# 4. 子查询详细解释
## 4.1 WHERE子句中的子查询
### 示例1：查询价格高于平均价格的商品
```sql
SELECT id, name, price
FROM products
WHERE price > (SELECT AVG(price) FROM products);
```

**解释**：

+ 这个查询分为两部分：内部子查询和外部主查询
+ 内部子查询：`SELECT AVG(price) FROM products` 计算所有商品的平均价格
+ 外部主查询：选择价格高于该平均值的商品
+ 子查询在WHERE子句中作为比较值使用
+ 子查询先执行，计算出一个单一的数值（平均价格）
+ 然后主查询使用这个值作为筛选条件
+ 结果返回所有价格高于平均价格的商品的ID、名称和价格
+ 这种查询适用于找出高于平均水平的商品，可用于促销决策或价格分析

### 示例2：查询购买过iPhone 13的用户
```sql
SELECT id, username, email
FROM users
WHERE id IN (
    SELECT DISTINCT o.user_id
    FROM orders o
    INNER JOIN order_items oi ON o.id = oi.order_id
    WHERE oi.product_name = 'iPhone 13'
);
```

**解释**：

+ 这个查询也分为内部子查询和外部主查询
+ 内部子查询：查找所有购买过"iPhone 13"的用户ID
    - 连接`orders`和`order_items`表
    - 筛选商品名称为"iPhone 13"的订单项
    - 使用DISTINCT去除重复的用户ID（一个用户可能多次购买同一商品）
    - 返回一个用户ID列表
+ 外部主查询：从用户表中选择ID在该列表中的用户
+ `WHERE id IN (...)`条件判断用户ID是否在子查询结果中
+ 结果返回所有曾购买过iPhone 13的用户信息
+ 这种查询可用于针对特定商品的用户群体分析或营销活动

## 4.2 FROM子句中的子查询
### 示例：查询每个分类中最贵的商品
```sql
SELECT pc.name AS category_name, p.name AS product_name, p.price
FROM products p
INNER JOIN (
    SELECT category_id, MAX(price) AS max_price
    FROM products
    GROUP BY category_id
) AS max_products ON p.category_id = max_products.category_id AND p.price = max_products.max_price
INNER JOIN product_categories pc ON p.category_id = pc.id;
```

**解释**：

+ 这个查询使用了子查询作为FROM子句中的派生表
+ 内部子查询：
    - `SELECT category_id, MAX(price) AS max_price FROM products GROUP BY category_id`
    - 按分类分组，计算每个分类中的最高价格
    - 返回包含分类ID和对应最高价格的结果集
    - 这个结果集被命名为`max_products`，作为一个临时表使用
+ 外部主查询：
    - 连接`products`表、子查询结果和`product_categories`表
    - 连接条件1：商品的分类ID与子查询中的分类ID匹配
    - 连接条件2：商品的价格等于该分类的最高价格
    - 再连接分类表以获取分类名称
+ 结果显示每个分类中价格最高的商品的分类名称、商品名称和价格
+ 这种查询适用于找出各个分类中的高端产品或旗舰产品
+ FROM子句中的子查询允许你先生成一个临时结果集，然后将其作为表与其他表连接

## 4.3 SELECT子句中的子查询
### 示例：查询每个用户的订单数量
```sql
SELECT u.username, 
       (SELECT COUNT(*) FROM orders WHERE user_id = u.id) AS order_count
FROM users u;
```

**解释**：

+ 这个查询在SELECT子句中使用了相关子查询
+ 外部主查询：从用户表选择所有用户
+ 内部子查询：`SELECT COUNT(*) FROM orders WHERE user_id = u.id`
    - 对每个用户，计算订单表中与该用户ID匹配的订单数量
    - 这是一个相关子查询，因为它引用了外部查询的表别名`u`
    - 子查询为每个用户分别执行一次
+ `AS order_count`将子查询结果命名为"order_count"列
+ 结果包含所有用户的用户名和对应的订单数量
+ 对于没有订单的用户，order_count显示为0
+ 这种查询适用于用户活跃度分析，可以方便地查看每个用户的订单情况
+ SELECT子句中的子查询必须返回单一值（标量子查询），否则会报错

## 4.4 子查询的进阶用法
### 示例1：使用EXISTS判断存在性
```sql
-- 查询至少有一个订单的用户
SELECT username, email
FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders WHERE user_id = u.id
);
```

**解释**：

+ 这个查询使用EXISTS操作符检查子查询是否返回结果
+ 内部子查询：检查是否存在与当前用户ID匹配的订单
+ `SELECT 1`是一个常见做法，表示我们只关心记录是否存在，不关心返回的具体值
+ EXISTS返回布尔值：如果子查询返回任何行，则为TRUE；否则为FALSE
+ 外部查询只选择EXISTS条件为TRUE的用户
+ 这种查询可用于筛选有订单记录的活跃用户

### 示例2：使用ANY/ALL进行比较
```sql
-- 查询价格高于任何电子产品分类商品的服装商品
SELECT p.name, p.price, pc.name AS category_name
FROM products p
JOIN product_categories pc ON p.category_id = pc.id
WHERE pc.parent_id = 2 -- 服装分类
AND p.price > ANY (
    SELECT price FROM products 
    WHERE category_id IN (SELECT id FROM product_categories WHERE parent_id = 1) -- 电子产品分类
);
```

**解释**：

+ 这个查询使用ANY操作符进行子查询比较
+ 内部嵌套子查询：`SELECT id FROM product_categories WHERE parent_id = 1`选择所有电子产品分类的ID
+ 中间子查询：选择所有电子产品分类下商品的价格列表
+ 外部主查询：选择服装分类下且价格高于任何一个电子产品的商品
+ `p.price > ANY (...)`条件表示价格大于子查询结果中的任意一个值
+ 这种查询可用于跨分类的价格比较分析

子查询是SQL中非常强大的功能，可以在WHERE、FROM和SELECT子句中使用，还可以嵌套多层。通过合理使用子查询，可以实现复杂的数据筛选和计算逻辑，解决许多单一查询难以解决的问题。

# 5. 聚合函数
## 5.1 COUNT()
### 示例1：计算总用户数
```sql
SELECT COUNT(*) AS total_users FROM users;
```

**解释**：

+ `COUNT(*)`函数计算users表中的总行数（所有用户记录）
+ 星号`*`表示计算所有行，不忽略NULL值
+ `AS total_users`将结果列命名为"total_users"
+ 返回一个单一值，表示系统中用户的总数量
+ 这是获取表记录总数的最基本用法

### 示例2：计算每个用户的订单数
```sql
SELECT u.username, COUNT(o.id) AS order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username;
```

**解释**：

+ 此查询计算每个用户的订单数量
+ `LEFT JOIN`确保返回所有用户，即使他们没有订单
+ `COUNT(o.id)`计算每个用户的订单ID数量
    - 注意使用`o.id`而不是`*`，这样当用户没有订单时，计数为0（因为o.id为NULL，而COUNT不计算NULL值）
+ `GROUP BY u.id, u.username`按用户分组，每个用户生成一行结果
+ 结果包含用户名和对应的订单数量
+ 适用于分析用户活跃度或消费频率

## 5.2 SUM()
### 示例1：计算所有订单的总金额
```sql
SELECT SUM(payment_amount) AS total_sales FROM orders WHERE order_status >= 2;
```

**解释**：

+ `SUM(payment_amount)`计算payment_amount列的总和
+ `WHERE order_status >= 2`筛选条件：只计算已支付订单（状态≥2）
+ `AS total_sales`将结果列命名为"total_sales"
+ 返回一个单一值，表示所有已支付订单的总金额
+ 这种查询常用于财务报表，计算总销售额

### 示例2：计算每个用户的消费总额
```sql
SELECT u.username, SUM(o.payment_amount) AS total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id AND o.order_status >= 2
GROUP BY u.id, u.username;
```

**解释**：

+ 此查询计算每个用户的总消费金额
+ `LEFT JOIN`确保返回所有用户，即使他们没有付款订单
+ JOIN条件包含`o.order_status >= 2`，只统计已支付订单
+ `SUM(o.payment_amount)`计算每个用户的已支付订单金额总和
    - 如果用户没有已支付订单，结果为NULL
+ `GROUP BY u.id, u.username`按用户分组
+ 结果包含用户名和对应的总消费金额
+ 适用于用户消费行为分析，识别高价值客户

## 5.3 AVG()
### 示例1：计算商品的平均价格
```sql
SELECT AVG(price) AS avg_price FROM products;
```

**解释**：

+ `AVG(price)`计算price列的平均值
+ `AS avg_price`将结果列命名为"avg_price"
+ 返回一个单一值，表示所有商品的平均价格
+ 这种查询可用于价格分析，了解商品的整体价格水平

### 示例2：计算每个分类的商品平均价格
```sql
SELECT pc.name, AVG(p.price) AS avg_price
FROM products p
INNER JOIN product_categories pc ON p.category_id = pc.id
GROUP BY p.category_id, pc.name;
```

**解释**：

+ 此查询计算每个商品分类的平均价格
+ `INNER JOIN`连接产品表和分类表，获取分类名称
+ `AVG(p.price)`计算每个分类中所有商品的平均价格
+ `GROUP BY p.category_id, pc.name`按分类分组
+ 结果包含分类名称和对应的平均商品价格
+ 适用于分类价格分析，了解不同分类商品的价格差异
+ 可用于调整定价策略或进行市场定位

## 5.4 MAX() 和 MIN()
### 示例1：查找最贵和最便宜的商品
```sql
SELECT MAX(price) AS max_price, MIN(price) AS min_price FROM products;
```

**解释**：

+ `MAX(price)`查找price列的最大值（最贵商品价格）
+ `MIN(price)`查找price列的最小值（最便宜商品价格）
+ 两个聚合函数在一个查询中组合使用
+ 返回两个值：最高价格和最低价格
+ 这种查询可用于了解价格范围，进行价格区间分析

### 示例2：查找每个分类中最贵和最便宜的商品
```sql
SELECT pc.name, MAX(p.price) AS max_price, MIN(p.price) AS min_price
FROM products p
INNER JOIN product_categories pc ON p.category_id = pc.id
GROUP BY p.category_id, pc.name;
```

**解释**：

+ 此查询计算每个商品分类的价格范围
+ `INNER JOIN`连接产品表和分类表
+ `MAX(p.price)`查找每个分类中的最高商品价格
+ `MIN(p.price)`查找每个分类中的最低商品价格
+ `GROUP BY p.category_id, pc.name`按分类分组
+ 结果包含分类名称、最高价格和最低价格
+ 适用于分析各分类的价格区间和价格分布
+ 可帮助确定分类内部的价格策略和产品定位

## 5.5 聚合函数的进阶用法
### 示例1：组合使用多个聚合函数
```sql
-- 全面分析商品价格
SELECT 
    COUNT(*) AS total_products,
    AVG(price) AS avg_price,
    MAX(price) AS max_price,
    MIN(price) AS min_price,
    SUM(price) AS sum_price,
    STDDEV(price) AS price_deviation
FROM products;
```

**解释**：

+ 此查询同时使用多个聚合函数对商品价格进行全面分析
+ `COUNT(*)`：计算商品总数
+ `AVG(price)`：计算平均价格
+ `MAX(price)`和`MIN(price)`：找出价格范围
+ `SUM(price)`：计算所有价格总和
+ `STDDEV(price)`：计算价格的标准差，衡量价格分散程度
+ 结果提供了商品价格的完整统计信息
+ 这种综合分析适用于数据概览和统计报表

### 示例2：使用WITH ROLLUP获取汇总数据
```sql
-- 按分类层级统计商品数量并汇总
SELECT 
    IFNULL(pc_parent.name, '所有分类') AS parent_category,
    IFNULL(pc.name, '小计') AS category,
    COUNT(p.id) AS product_count
FROM products p
JOIN product_categories pc ON p.category_id = pc.id
LEFT JOIN product_categories pc_parent ON pc.parent_id = pc_parent.id
GROUP BY pc_parent.name, pc.name WITH ROLLUP;
```

**解释**：

+ 此查询使用`WITH ROLLUP`扩展了分组聚合功能
+ 按父分类和子分类两级分组计算商品数量
+ `WITH ROLLUP`自动生成各级汇总行
    - 每个父分类下的子分类小计
    - 所有分类的总计
+ `IFNULL`函数用于将汇总行中的NULL值替换为有意义的标签
+ 结果包含层次化的商品数量统计，包括小计和总计
+ 这种汇总报表适用于多层次的数据分析和报表生成

聚合函数是数据分析的基础工具，通过对数据进行汇总计算，可以发现数据中的模式和趋势。结合GROUP BY子句，可以对数据进行分组分析，深入了解不同类别或分组的特征。在实际应用中，聚合函数常用于生成各类统计报表和数据分析结果。



# 6. 分组和排序
## 6.1 GROUP BY
### 示例1：计算每个用户的订单数量和消费总额
```sql
SELECT u.username, COUNT(o.id) AS order_count, IFNULL(SUM(o.payment_amount), 0) AS total_spent
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.username;
```

**解释**：

+ 此查询按用户分组，计算每个用户的订单数量和消费总额
+ `LEFT JOIN`确保返回所有用户，即使他们没有订单
+ `COUNT(o.id)`计算每个用户的订单数量（NULL值不计入）
+ `IFNULL(SUM(o.payment_amount), 0)`计算每个用户的消费总额，如果没有订单则显示0而不是NULL
+ `GROUP BY u.id, u.username`按用户ID和用户名分组
    - 包含用户ID是为了确保准确分组（避免同名用户混淆）
    - 包含用户名是为了在结果中显示用户名
+ 结果显示每个用户的用户名、订单数量和总消费金额
+ 适用于用户消费行为分析，了解用户活跃度和价值

### 示例2：计算每个分类的商品数量
```sql
SELECT pc.name, COUNT(p.id) AS product_count
FROM product_categories pc
LEFT JOIN products p ON pc.id = p.category_id
GROUP BY pc.id, pc.name;
```

**解释**：

+ 此查询按商品分类分组，计算每个分类的商品数量
+ `LEFT JOIN`确保返回所有分类，即使该分类下没有商品
+ `COUNT(p.id)`计算每个分类中的商品数量（空分类显示为0）
+ `GROUP BY pc.id, pc.name`按分类ID和分类名分组
+ 结果显示每个分类的名称和对应的商品数量
+ 适用于分析商品分类的分布情况，找出商品丰富或稀缺的分类
+ 可用于指导产品开发和库存管理决策

## 6.2 HAVING
### 示例1：查找购买金额超过1万元的用户
```sql
SELECT u.username, SUM(o.payment_amount) AS total_spent
FROM users u
INNER JOIN orders o ON u.id = o.user_id AND o.order_status >= 2
GROUP BY u.id, u.username
HAVING total_spent > 10000;
```

**解释**：

+ 此查询筛选出消费总额超过1万元的高价值用户
+ `INNER JOIN`连接用户表和订单表，条件包括订单状态≥2（已支付订单）
+ `SUM(o.payment_amount)`计算每个用户的已支付订单总金额
+ `GROUP BY u.id, u.username`按用户分组
+ `HAVING total_spent > 10000`筛选分组结果，只保留总消费额超过1万元的用户
    - 注意HAVING与WHERE的区别：HAVING用于筛选分组后的结果，WHERE用于筛选原始数据行
    - HAVING子句可以使用聚合函数（如SUM）或别名，而WHERE不能
+ 结果显示高价值用户及其消费总额
+ 适用于VIP客户识别、忠诚度计划或精准营销活动

### 示例2：查找平均价格超过5000元的分类
```sql
SELECT pc.name, AVG(p.price) AS avg_price
FROM products p
INNER JOIN product_categories pc ON p.category_id = pc.id
GROUP BY p.category_id, pc.name
HAVING avg_price > 5000;
```

**解释**：

+ 此查询筛选出平均价格超过5000元的高端商品分类
+ `INNER JOIN`连接产品表和分类表
+ `AVG(p.price)`计算每个分类下商品的平均价格
+ `GROUP BY p.category_id, pc.name`按分类分组
+ `HAVING avg_price > 5000`筛选出平均价格高于5000元的分类
    - 使用别名`avg_price`简化了HAVING子句
+ 结果显示高端分类及其平均商品价格
+ 适用于高端产品分析、定价策略调整或市场定位研究

## 6.3 ORDER BY
### 示例1：按价格从高到低排序商品
```sql
SELECT name, price FROM products ORDER BY price DESC;
```

**解释**：

+ 此查询返回所有商品，按价格降序排列
+ `SELECT name, price`选择商品名称和价格两个字段
+ `ORDER BY price DESC`按价格字段降序排序（从高到低）
+ 若不指定DESC，则默认为ASC（升序，从低到高）
+ 结果按价格从高到低排列，最贵的商品显示在最前面
+ 这种简单排序适用于价格排行、展示高端产品等场景

### 示例2：按销量从高到低排序商品
```sql
SELECT p.name, SUM(oi.quantity) AS sales_count
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
GROUP BY p.id, p.name
ORDER BY sales_count DESC;
```

**解释**：

+ 此查询计算每个商品的销售总量，并按销量降序排序
+ `LEFT JOIN`连接产品表和订单项表，确保包含所有商品
+ `SUM(oi.quantity)`计算每个商品的销售总数量
+ `GROUP BY p.id, p.name`按商品分组
+ `ORDER BY sales_count DESC`按计算出的销量降序排序
+ 结果显示所有商品及其销量，按销量从高到低排列
+ 适用于畅销商品分析、库存管理或产品推荐

## 6.4 GROUP BY 和 ORDER BY 的高级用法
### 示例1：多级分组和多列排序
```sql
-- 按年月统计销售额，并按年月排序
SELECT 
    YEAR(o.payment_time) AS year,
    MONTH(o.payment_time) AS month,
    SUM(o.payment_amount) AS monthly_sales
FROM orders o
WHERE o.order_status >= 2 AND o.payment_time IS NOT NULL
GROUP BY year, month
ORDER BY year ASC, month ASC;
```

**解释**：

+ 此查询按年和月两级分组统计销售额，并按时间顺序排序
+ `YEAR(o.payment_time)`和`MONTH(o.payment_time)`提取订单支付时间的年份和月份
+ `WHERE`子句筛选已支付且有支付时间的订单
+ `GROUP BY year, month`按年和月分组（使用了别名）
+ `ORDER BY year ASC, month ASC`先按年升序，再按月升序排列
+ 结果显示每月销售总额的时间序列，按时间顺序排列
+ 适用于销售趋势分析、季节性波动研究或月度财务报表

### 示例2：分组结合计算字段和条件排序
```sql
-- 分析每个分类的库存价值，按库存价值降序排序
SELECT 
    pc.name AS category_name,
    COUNT(p.id) AS product_count,
    AVG(p.price) AS avg_price,
    SUM(p.stock) AS total_stock,
    SUM(p.price * p.stock) AS inventory_value
FROM products p
JOIN product_categories pc ON p.category_id = pc.id
WHERE p.status = 1  -- 仅统计上架商品
GROUP BY p.category_id, pc.name
HAVING total_stock > 0  -- 仅显示有库存的分类
ORDER BY inventory_value DESC;
```

**解释**：

+ 此查询计算每个分类的多个统计指标，重点是库存价值
+ `JOIN`连接产品和分类表
+ `WHERE p.status = 1`筛选条件：只包括上架的商品
+ 计算多个聚合指标：
    - 商品数量：`COUNT(p.id)`
    - 平均价格：`AVG(p.price)`
    - 总库存量：`SUM(p.stock)`
    - 库存价值：`SUM(p.price * p.stock)`（每件商品价格乘以库存数量的总和）
+ `GROUP BY p.category_id, pc.name`按分类分组
+ `HAVING total_stock > 0`筛选条件：只包括有库存的分类
+ `ORDER BY inventory_value DESC`按库存价值降序排序
+ 结果显示各分类的库存情况和价值，从最高价值分类开始
+ 适用于库存管理、资产评估或采购计划制定

### 示例3：GROUP BY与LIMIT结合使用
```sql
-- 查找销量最高的5个商品
SELECT p.name, SUM(oi.quantity) AS total_sold
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.order_status >= 2  -- 已支付订单
GROUP BY p.id, p.name
ORDER BY total_sold DESC
LIMIT 5;
```

**解释**：

+ 此查询找出销量最高的5个商品
+ 多表连接：产品表、订单项表和订单表
+ `WHERE o.order_status >= 2`筛选条件：只计算已支付订单的销量
+ `SUM(oi.quantity)`计算每个商品的总销售数量
+ `GROUP BY p.id, p.name`按商品分组
+ `ORDER BY total_sold DESC`按销量降序排序
+ `LIMIT 5`限制结果只返回前5条记录
+ 结果是一个销量排行榜，显示最畅销的5个商品
+ 适用于热销商品分析、商品推荐或营销决策支持

GROUP BY和ORDER BY是数据分析中最常用的子句，它们可以帮助我们将原始数据转化为有意义的业务洞察。GROUP BY通过分组汇总数据，而ORDER BY则确保数据以最有意义的顺序呈现。结合HAVING子句可以进一步筛选分组结果，实现更精确的数据分析。

# 7. 常用函数详细解释
## 7.1 字符串函数
### 示例1：字符串连接
```sql
SELECT CONCAT(username, ' (', email, ')') AS user_info FROM users;
```

**解释**：

+ `CONCAT()`函数用于连接多个字符串
+ 此查询连接了用户名、括号和电子邮箱，格式为"用户名 (邮箱)"
+ `username`：用户表中的用户名字段
+ `' ('`和`')'`：固定的字符串文本，作为分隔符
+ `email`：用户表中的电子邮箱字段
+ `AS user_info`：将结果列命名为"user_info"
+ 结果示例："张三 (zhangsan@example.com)"
+ 适用于生成更友好的用户显示名称或在报表中合并多个相关字段

### 示例2：大小写转换
```sql
SELECT UPPER(username) AS upper_name, LOWER(email) AS lower_email FROM users;
```

**解释**：

+ 此查询演示了两个字符串大小写转换函数
+ `UPPER(username)`：将用户名转换为全大写
    - 例如："张三" → "张三"（中文不变），"Tom" → "TOM"
+ `LOWER(email)`：将电子邮箱转换为全小写
    - 例如："User@Example.com" → "user@example.com"
+ 结果包含转换后的用户名和电子邮箱
+ 适用于标准化数据格式、不区分大小写的比较或展示需求
+ 电子邮箱通常存储为小写形式，以确保唯一性检查的准确性

### 示例3：字符串长度
```sql
SELECT username, LENGTH(username) AS name_length FROM users;
```

**解释**：

+ `LENGTH()`函数计算字符串的字节长度
+ `LENGTH(username)`返回每个用户名的字节长度
    - 注意：对于中文等多字节字符，一个字符可能占用多个字节
    - 如果需要计算字符数而非字节数，可使用`CHAR_LENGTH()`函数
+ `AS name_length`将结果列命名为"name_length"
+ 结果显示每个用户的用户名及其长度
+ 适用于数据验证、用户输入限制或数据分析

### 示例4：子字符串
```sql
SELECT order_no, SUBSTRING(order_no, 1, 8) AS order_date FROM orders;
```

**解释**：

+ `SUBSTRING()`函数用于提取字符串的一部分
+ `SUBSTRING(order_no, 1, 8)`从order_no字段中提取从第1个位置开始的8个字符
    - 在MySQL中，字符串位置从1开始计数
    - 示例：从"2022040100001"提取"20220401"（表示日期部分）
+ `AS order_date`将结果列命名为"order_date"
+ 结果显示订单号及其日期部分
+ 适用于从格式化字符串中提取特定部分，如从订单号中提取日期、地区代码等
+ 这种方法常用于处理包含多种信息的编码字段

## 7.2 数值函数
### 示例1：四舍五入
```sql
SELECT name, price, ROUND(price, 0) AS rounded_price FROM products;
```

**解释**：

+ `ROUND()`函数用于四舍五入数值
+ `ROUND(price, 0)`将价格四舍五入到整数（0位小数）
    - 第一个参数是要舍入的数值
    - 第二个参数是保留的小数位数
    - 例如：5999.90 → 6000，499.20 → 499
+ `AS rounded_price`将结果列命名为"rounded_price"
+ 结果显示商品名称、原始价格和舍入后的价格
+ 适用于价格显示、统计分析或设定价格区间

### 示例2：向上取整和向下取整
```sql
SELECT name, price, CEILING(price) AS ceiling_price, FLOOR(price) AS floor_price FROM products;
```

**解释**：

+ 此查询展示了两个取整函数
+ `CEILING(price)`：向上取整，返回大于或等于参数的最小整数
    - 例如：5999.90 → 6000，499.00 → 499
+ `FLOOR(price)`：向下取整，返回小于或等于参数的最大整数
    - 例如：5999.90 → 5999，499.99 → 499
+ 结果显示商品名称、原始价格、向上取整价格和向下取整价格
+ 向上取整常用于计算需要完整单位的场景（如配送箱数）
+ 向下取整常用于忽略零头或进行保守估计

## 7.3 日期时间函数
### 示例1：获取当前日期和时间
```sql
SELECT NOW(), CURDATE(), CURTIME();
```

**解释**：

+ 此查询展示了三个获取当前日期时间的函数
+ `NOW()`：返回当前日期和时间
    - 格式：'YYYY-MM-DD HH:MM:SS'
    - 例如：'2023-05-20 15:30:45'
+ `CURDATE()`：返回当前日期（不包含时间）
    - 格式：'YYYY-MM-DD'
    - 例如：'2023-05-20'
+ `CURTIME()`：返回当前时间（不包含日期）
    - 格式：'HH:MM:SS'
    - 例如：'15:30:45'
+ 结果包含三个时间相关的值
+ 常用于记录数据创建/修改时间、生成报表或日志记录

### 示例2：提取日期部分
```sql
SELECT order_no, payment_time, 
       YEAR(payment_time) AS year,
       MONTH(payment_time) AS month,
       DAY(payment_time) AS day,
       WEEKDAY(payment_time) AS weekday
FROM orders
WHERE payment_time IS NOT NULL;
```

**解释**：

+ 此查询从支付时间中提取各个日期部分
+ `YEAR(payment_time)`：提取年份（如2023）
+ `MONTH(payment_time)`：提取月份（1-12）
+ `DAY(payment_time)`：提取日（1-31）
+ `WEEKDAY(payment_time)`：提取星期（0=周一，1=周二，...，6=周日）
    - 注意：MySQL的WEEKDAY()从0开始计数，表示周一
+ `WHERE payment_time IS NOT NULL`确保只处理有支付时间的订单
+ 结果显示订单号、支付时间及其拆分的各个日期部分
+ 适用于按年、月、日或星期进行数据分析和统计

### 示例3：日期格式化
```sql
SELECT order_no, payment_time, 
       DATE_FORMAT(payment_time, '%Y年%m月%d日 %H:%i:%s') AS formatted_time
FROM orders
WHERE payment_time IS NOT NULL;
```

**解释**：

+ `DATE_FORMAT()`函数用于自定义日期时间的显示格式
+ `DATE_FORMAT(payment_time, '%Y年%m月%d日 %H:%i:%s')`将支付时间格式化为中文友好格式
    - `%Y`：四位数年份（如2023）
    - `%m`：两位数月份（01-12）
    - `%d`：两位数日期（01-31）
    - `%H`：24小时制小时（00-23）
    - `%i`：分钟（00-59）
    - `%s`：秒（00-59）
    - 例如：'2023年05月20日 15:30:45'
+ 结果显示订单号、原始支付时间和格式化后的支付时间
+ 适用于用户界面显示、报表生成或本地化需求

## 7.4 条件函数
### 示例1：IF函数
```sql
SELECT name, stock, 
       IF(stock > 0, '有货', '无货') AS stock_status 
FROM products;
```

**解释**：

+ `IF()`函数根据条件返回不同的值，类似三元运算符
+ `IF(stock > 0, '有货', '无货')`
    - 第一个参数是条件表达式：stock > 0
    - 第二个参数是条件为真时返回的值：'有货'
    - 第三个参数是条件为假时返回的值：'无货'
+ 结果显示商品名称、库存数量和库存状态（有货/无货）
+ 适用于将数值或复杂状态转换为人类可读的描述
+ 常用于报表生成、用户界面显示或数据分类

### 示例2：CASE表达式
```sql
SELECT order_no, order_status,
       CASE order_status
           WHEN 1 THEN '待付款'
           WHEN 2 THEN '已付款待发货'
           WHEN 3 THEN '已发货'
           WHEN 4 THEN '已完成'
           WHEN 5 THEN '已取消'
           ELSE '未知状态'
       END AS status_desc
FROM orders;
```

**解释**：

+ `CASE`表达式用于多条件判断，类似编程语言中的switch语句
+ 此查询将数字状态码转换为描述性文本
+ 简单CASE语法：将order_status与每个WHEN子句的值比较
    - WHEN 1：状态码为1时，返回'待付款'
    - WHEN 2：状态码为2时，返回'已付款待发货'
    - ...以此类推
    - ELSE：如果没有匹配项，返回'未知状态'
    - END：标记CASE表达式结束
+ `AS status_desc`将结果列命名为"status_desc"
+ 结果显示订单号、原始状态码和对应的状态描述
+ 非常适合将数据库中的代码转换为用户可读的文本
+ 常用于报表、用户界面或API响应

### 示例3：搜索型CASE表达式
```sql
-- 按价格区间划分商品档次
SELECT name, price,
       CASE 
           WHEN price < 100 THEN '低价'
           WHEN price >= 100 AND price < 1000 THEN '中价'
           WHEN price >= 1000 AND price < 5000 THEN '高价'
           WHEN price >= 5000 THEN '豪华'
           ELSE '未定价'
       END AS price_level
FROM products;
```

**解释**：

+ 这是搜索型CASE表达式，与简单CASE不同，它评估每个WHEN条件表达式
+ 此查询根据价格范围对商品进行分类
+ 搜索型CASE语法：评估每个WHEN后的条件表达式
    - WHEN price < 100：价格低于100元，归为'低价'
    - WHEN price >= 100 AND price < 1000：价格在100至1000元之间，归为'中价'
    - ...以此类推
    - ELSE：如果所有条件都不满足，返回'未定价'（处理NULL值）
+ 结果显示商品名称、原始价格和价格档次
+ 适用于数据分类、区间分析或客户细分
+ 在报表中特别有用，可以将连续数值转换为离散类别

## 7.5 高级函数用法
### 示例1：组合使用多个函数
```sql
-- 提取并格式化订单号中的日期部分
SELECT 
    order_no,
    SUBSTRING(order_no, 1, 8) AS date_part,
    CONCAT(
        SUBSTRING(order_no, 1, 4), '-',
        SUBSTRING(order_no, 5, 2), '-',
        SUBSTRING(order_no, 7, 2)
    ) AS formatted_date
FROM orders;
```

**解释**：

+ 此查询组合使用SUBSTRING和CONCAT函数处理订单号
+ 假设订单号格式为"YYYYMMDDNNNNN"，其中前8位表示日期
+ `SUBSTRING(order_no, 1, 8)`提取前8位作为日期部分
+ CONCAT和多个SUBSTRING的组合用于将日期部分重新格式化为标准格式：
    - 提取年份（前4位）+ '-' + 提取月份（接下来2位）+ '-' + 提取日期（再接下来2位）
    - 例如："20220401" → "2022-04-01"
+ 结果包含原订单号、日期部分和格式化后的日期
+ 适用于数据清洗、格式转换或提取业务信息

### 示例2：条件聚合
```sql
-- 分析不同支付方式的订单金额
SELECT 
    SUM(IF(payment_method = 1, payment_amount, 0)) AS wechat_amount,
    SUM(IF(payment_method = 2, payment_amount, 0)) AS alipay_amount,
    SUM(IF(payment_method = 3, payment_amount, 0)) AS bank_amount,
    SUM(payment_amount) AS total_amount
FROM orders
WHERE order_status >= 2;  -- 已支付订单
```

**解释**：

+ 此查询使用IF函数结合SUM聚合函数，实现条件聚合
+ 对于每种支付方式：
    - `SUM(IF(payment_method = X, payment_amount, 0))`
    - 当支付方式匹配时，计入该笔订单金额；否则计为0
    - 这样就分别计算出了每种支付方式的总金额
+ 最后一列计算所有支付方式的总金额
+ `WHERE order_status >= 2`筛选已支付的订单
+ 结果显示微信支付、支付宝支付、银行卡支付的总金额及所有支付的总金额
+ 这种技术称为"条件聚合"，可在一次查询中计算多个分组的聚合值
+ 比创建多个分组或使用多个查询更高效
+ 特别适用于报表生成和数据分析

MySQL中的函数极大地增强了数据处理和转换能力，从简单的数据格式化到复杂的条件逻辑处理，都可以通过各种内置函数实现。熟练掌握这些函数可以使SQL查询更加灵活和强大，减少对应用程序代码的依赖，提高数据处理效率。



> 更新: 2025-04-23 20:21:16  
> 原文: <https://www.yuque.com/linuxer/gscfv1/wytt2800889m6f21>