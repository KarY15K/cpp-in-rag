# 第02章 Linux系统编程概述

初识 Linux 应用编程 对于许多初次接触 Linux 应用编程的读者来说，可能对应用编程（也称为系统编程）的概念不太熟悉。

+ 应用编程是指编写直接与操作系统交互的软件，如文件操作、进程管理等。
+ 相比之下，驱动编程涉及底层硬件控制。
+ 而裸机编程则是在没有操作系统支持的情况下直接在硬件上运行程序。



因此，在正式学习 Linux 应用编程之前，有必要向大家介绍这些基本概念，帮助大家从整体上理解什么是应用编程，以及它与驱动编程和裸机编程的区别。



本章将会讨论如下主题内容。

+ 何为系统调用；
+ 何为库函数；
+ 应用程序的 main()函数；
+ 应用程序开发环境的介绍。



# 1.1 系统调用
系统调用（system call）其实是 Linux 内核提供给应用层的应用编程接口（API），是 Linux 应用层进入 内核的入口。不止 Linux 系统，所有的操作系统都会向应用层提供系统调用，应用程序通过系统调用来使用 操作系统提供的各种服务。

通过系统调用，Linux 应用程序可以请求内核以自己的名义执行某些事情，譬如打开磁盘中的文件、读 写文件、关闭文件以及控制其它硬件外设。

通过系统调用 API，应用层可以实现与内核的交互，其关系可通过下图简单描述：

![67a31e4751ff4.png](./img/eDpeE6MuDUpfjfBb/1745772124831-edc8cbc9-7649-4a80-b163-d5d83e55271e-946472.png)



图 1.1.1  内核、系统调用与应用程序

+ **内核**

Linux 内核是操作系统的核心部分，是整个系统的 “心脏”。它负责管理系统的各种资源，包括文件系统、进程调度、内存分配、设备驱动等。内核运行在内核空间，拥有最高的权限，可以直接访问硬件资源。它的主要作用是为上层的系统程序和应用程序提供一个稳定、安全的运行环境。例如，内核负责为不同的进程分配 CPU 时间片，保证各个进程能够有序地运行；管理内存，为进程分配和回收内存空间；处理硬件设备的中断请求，实现设备与系统的交互。内核的稳定性和性能对整个系统的运行起着至关重要的作用，一旦内核出现问题，可能导致系统崩溃。

+ **系统调用**

系统调用是应用程序与内核交互的接口。应用程序运行在用户空间，不能直接访问硬件资源，需要通过系统调用向内核请求服务。系统调用是一种特殊的函数调用，它允许应用程序以受控的方式进入内核空间，执行内核提供的特定功能。例如，当应用程序需要创建一个新文件时，它会调用 open 系统调用，内核接收到这个请求后，会在内核空间执行创建文件的操作，并将结果返回给应用程序。系统调用分为多种类型，包括进程控制、文件管理、设备管理、信息维护和通信等。通过系统调用，应用程序可以安全地使用内核提供的服务，而无需关心底层硬件的细节。

+ **应用程序**

应用程序是为了满足用户特定需求而开发的软件，运行在用户空间。它基于系统调用提供的接口，调用内核的功能来完成各种任务。应用程序的目的是为用户提供有用的功能，如文字处理软件、游戏、浏览器等。应用程序的开发相对简单，开发者无需了解底层硬件的细节，只需要通过系统调用与内核进行交互。应用程序的运行依赖于内核和系统调用，没有它们的支持，应用程序无法正常工作。

+ **三者之间的关系**
    - 应用程序依赖于系统调用和内核来实现其功能。当应用程序需要访问硬件资源或执行特权操作时，它会通过系统调用向内核发出请求。
    - 系统调用是连接应用程序和内核的桥梁，它提供了一种安全、受控的方式让应用程序与内核进行交互。
    - 内核是系统调用的执行者，它接收到系统调用请求后，会根据请求的类型执行相应的操作，并将结果返回给应用程序。



下面是一个简单的 Linux 应用程序示例read_file.c，该程序**使用系统调用**打开一个文件，读取文件内容并将其输出到标准输出。

```c
// read_file.c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE 1024

int main() {
    int fd;  // 文件描述符
    char buffer[BUFFER_SIZE];
    ssize_t bytes_read;

    // 打开文件
    fd = open("test.txt", O_RDONLY);
    if (fd == -1) {
        perror("open");
        return EXIT_FAILURE;
    }

    // 读取文件内容
    while ((bytes_read = read(fd, buffer, BUFFER_SIZE)) > 0) {
        // 将读取的内容写入标准输出
        if (write(STDOUT_FILENO, buffer, bytes_read) != bytes_read) {
            perror("write");
            close(fd);
            return EXIT_FAILURE;
        }
    }

    if (bytes_read == -1) {
        perror("read");
        close(fd);
        return EXIT_FAILURE;
    }

    // 关闭文件
    if (close(fd) == -1) {
        perror("close");
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
```

**代码解释**

1. **包含头文件**：包含了必要的头文件，如`<stdio.h>`、`<stdlib.h>`、`<fcntl.h>`和`<unistd.h>`，这些头文件提供了系统调用和库函数的声明。
2. **打开文件**：使用`open`系统调用打开一个名为`test.txt`的文件，以只读模式打开。如果打开失败，使用`perror`函数输出错误信息并退出程序。
3. **读取文件内容**：使用`read`系统调用从文件中读取数据到缓冲区`buffer`中，每次最多读取`BUFFER_SIZE`字节。如果读取成功，使用`write`系统调用将读取的内容写入标准输出。
4. **关闭文件**：使用`close`系统调用关闭文件描述符。如果关闭失败，使用`perror`函数输出错误信息并退出程序。



**编译和运行**

将上述代码保存为`read_file.c`，然后使用以下命令进行编译：

```shell
gcc -o read_file read_file.c
```

运行程序：

```shell
./read_file
```

请确保当前目录下存在`test.txt`文件，否则程序会输出错误信息。

# 1.2 库函数
前面给大家介绍了系统调用，系统调用是内核直接向应用层提供的应用编程接口，譬如open、write 、 read、close 等，关于这些系统调用后面会给大家进行详细介绍。编写应用程序除了使用系统调用之外，我们 还可以使用库函数，本小节来聊一聊库函数。

常见的Linux库函数有：

+ **标准 C 库函数（libc）**，C 标准库是所有 C 程序运行的基础，提供了大量用于输入输出、字符串处理、内存管理、数学运算等基本功能的函数。它是 GNU C Library（glibc）的一部分，是 Linux 系统默认的 C 标准库实现。
+ **C++ 标准库**，C++ 标准库基于 C 标准库构建，并且增加了面向对象编程、模板编程等特性，提供了容器（如`vector`、`map`）、算法（如`sort`）、输入输出流等功能。
+ **libcurl**
    - **功能**：一个功能强大的网络传输库，支持多种协议（如 HTTP、FTP 等），用于实现网络数据的下载、上传等操作。
    - **示例场景**：编写爬虫程序、实现文件下载功能。

不局限于以上列举的库。



比如调用c库函数实现文件写入

```c
// fwrite_file.c
#include <stdio.h>

int main() {
    FILE *fp = fopen("test.txt", "w");
    if (fp != NULL) {
        fwrite("Hello, File!", 1, 12, fp);
        fclose(fp);
    }
    return 0;
}
```





# 1.3 main 函数
对学习过 C 语言编程的读者来说，譬如单片机编程、Windows 应用编程等，main 函数想必大家再熟悉 不过了，很多编程开发都是以 main 函数作为程序的入口函数，同样在 Linux 应用程序中，main 函数也是作为应用程序的入口函数存在，main  函数的形参一般会有两种写法，如果执行应用程序无需传参，则可以写 成如下形式：

```c
int main(void) 
{
/*  代码 */
}
```



如果在执行应用程序的时候需要向应用程序传递参数，则写法如下：

```c
int main(int argc, char **argv) 
{
/*  代码 */
}
```



参考范例print_args.c

```c
// print_args.c
#include <stdio.h>

int main(int argc, char **argv) {
    // 打印参数数量
    printf("命令行参数的数量: %d\n", argc);

    // 遍历并打印每个参数
    for (int i = 0; i < argc; i++) {
        printf("参数 %d: %s\n", i, argv[i]);
    }

    return 0;
}
```



**编译和运行示例**：

```shell
gcc -o print_args print_args.c
./print_args hello world "C programming"
```

**输出示例**：

```plain
命令行参数的数量: 4
参数 0: ./print_args
参数 1: hello
参数 2: world
参数 3: C programming
```





# 1.4 应用程序开发环境
 建议使用VMware虚拟机安装Ubuntu，Ubuntu版本建议使用20.04或者22.04。

更多内容参考 程序员老廖的自媒体链接：

[Linux C/C++开发环境搭建(系列视频)教程,vscode远程ubuntu调试多个c++文件，让你少走弯路_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1tx4y1b7j2/)



建议：这里vscode配置gdb调试代码，因为vscode的问题，不一定很方便，可以使用gdb命令来调试代码。



> 更新: 2025-04-18 16:50:04  
> 原文: <https://www.yuque.com/linuxer/gscfv1/ygdpegantyk7ivb6>